(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{362:function(a,v,_){"use strict";_.r(v);var t=_(3),i=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h3",{attrs:{id:"jdk、jre、堆与栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk、jre、堆与栈"}},[a._v("#")]),a._v(" JDK、JRE、堆与栈")]),a._v(" "),v("h4",{attrs:{id:"jdk与jre、jvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk与jre、jvm"}},[a._v("#")]),a._v(" JDK与JRE、JVM")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("JDK：java development kit（java开发工具），jdk8和java8是一个东西")])]),a._v(" "),v("li",[v("p",[a._v("JRE：java running nvironment（java运行环境）")])]),a._v(" "),v("li",[v("p",[a._v("JVM：java virtuak machine （java虚拟机）")])])]),a._v(" "),v("p",[v("strong",[a._v("JDK")]),a._v("包含三个部分，第一个部分是JRE和JVM，第二部分是基础类库，第三部分是java的开发工具；")]),a._v(" "),v("p",[v("strong",[a._v("JRE")]),a._v("，JDK中的JRE运行在JVM上，JRE的bin目录中有jvm.dll, java的lib目录中放的是一些java类库的class文件，已经打包成jar包。独立出来的JRE环境也需要有JVM。")]),a._v(" "),v("p",[v("strong",[a._v("JVM")]),a._v("，java编译后的class文件就是在JVM上运行的文件，只有JVM的话还不能完全支持class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。JVM的一次编译随处运行：JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改的运行。")]),a._v(" "),v("h4",{attrs:{id:"堆和栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈"}},[a._v("#")]),a._v(" 堆和栈：")]),a._v(" "),v("p",[a._v("JVM内存的划分有五片：")]),a._v(" "),v("p",[a._v("1.寄存器2.本地方法区3.方法区4.栈内存5.堆内存")]),a._v(" "),v("p",[v("strong",[a._v("栈内存")]),a._v("：栈内存首先时一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量，for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用于，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的声明周期都很短。")]),a._v(" "),v("p",[a._v("**堆内存：**存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封存数据，而且是封存多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，也就没有了。堆里的实体虽然不会被释放，但是会被当做垃圾，Java有垃圾回收机制不定时的收取。")]),a._v(" "),v("h3",{attrs:{id:"静态成员和静态方法、静态代码块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态成员和静态方法、静态代码块"}},[a._v("#")]),a._v(" 静态成员和静态方法、静态代码块")]),a._v(" "),v("h4",{attrs:{id:"静态变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态变量"}},[a._v("#")]),a._v(" 静态变量")]),a._v(" "),v("p",[a._v("类的成员变量可以分为以下两种：")]),a._v(" "),v("ol",[v("li",[a._v("静态变量（或称为类变量），指被 static 修饰的成员变量。")]),a._v(" "),v("li",[a._v("实例变量，指没有被 static 修饰的成员变量。")])]),a._v(" "),v("p",[a._v("静态变量与实例变量的区别如下：")]),a._v(" "),v("p",[a._v("1）静态变量")]),a._v(" "),v("ul",[v("li",[a._v("运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。")]),a._v(" "),v("li",[a._v("在类的内部，可以在任何方法内直接访问静态变量。")]),a._v(" "),v("li",[a._v("在其他类中，可以通过类名访问该类中的静态变量。")])]),a._v(" "),v("p",[a._v("2）实例变量")]),a._v(" "),v("ul",[v("li",[a._v("每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。")]),a._v(" "),v("li",[a._v("在类的内部，可以在非静态方法中直接访问实例变量。")]),a._v(" "),v("li",[a._v("在本类的静态方法或其他类中则需要通过类的实例对象进行访问。")])]),a._v(" "),v("p",[a._v("静态变量在类中的作用如下：")]),a._v(" "),v("ul",[v("li",[a._v("静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。")]),a._v(" "),v("li",[a._v("如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。")])]),a._v(" "),v("h4",{attrs:{id:"静态方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[a._v("#")]),a._v(" 静态方法")]),a._v(" "),v("p",[a._v("与成员变量类似，成员方法也可以分为以下两种：")]),a._v(" "),v("ol",[v("li",[a._v("静态方法（或称为类方法），指被 static 修饰的成员方法。")]),a._v(" "),v("li",[a._v("实例方法，指没有被 static 修饰的成员方法。")])]),a._v(" "),v("p",[a._v("静态方法与实例方法的区别如下：")]),a._v(" "),v("ul",[v("li",[a._v("静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。")]),a._v(" "),v("li",[a._v("在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。")])]),a._v(" "),v("h4",{attrs:{id:"静态代码块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态代码块"}},[a._v("#")]),a._v(" 静态代码块")]),a._v(" "),v("p",[a._v("静态代码块指 Java 类中的 static{ } 代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。")]),a._v(" "),v("p",[a._v("静态代码块的特点如下：")]),a._v(" "),v("ul",[v("li",[a._v("静态代码块类似于一个方法，但它不可以存在于任何方法体中。")]),a._v(" "),v("li",[a._v("静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。")]),a._v(" "),v("li",[a._v("Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。")]),a._v(" "),v("li",[a._v("如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。")]),a._v(" "),v("li",[a._v("静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。")])]),a._v(" "),v("h3",{attrs:{id:"finall修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finall修饰符"}},[a._v("#")]),a._v(" finall修饰符")]),a._v(" "),v("h4",{attrs:{id:"finall修饰变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finall修饰变量"}},[a._v("#")]),a._v(" finall修饰变量")]),a._v(" "),v("p",[a._v("final 修饰的变量即成为常量，只能赋值一次，但是 final 所修饰局部变量和成员变量有所不同。")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("final 修饰的局部变量必须使用之前被赋值一次才能使用。")])]),a._v(" "),v("li",[v("p",[a._v("final 修饰的成员变量在声明时没有赋值的叫“空白 final 变量”。空白 final 变量必须在构造方法或静态代码块中初始化。")])])]),a._v(" "),v("p",[v("strong",[a._v("注意")]),a._v("：final 修饰的变量不能被赋值这种说法是错误的，严格的说法是，final 修饰的变量不可被改变，一旦获得了初始值，该 final 变量的值就不能被重新赋值。")]),a._v(" "),v("p",[v("strong",[a._v("当使用 final 修饰基本类型变量时")]),a._v("，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。 "),v("strong",[a._v("但对于引用类型变量而言")]),a._v("，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。")]),a._v(" "),v("h4",{attrs:{id:"finall修饰方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finall修饰方法"}},[a._v("#")]),a._v(" finall修饰方法")]),a._v(" "),v("p",[a._v("final 修饰的方法不可被重写（但是可以被重载），如果出于某些原因，不希望子类重写父类的某个方法，则可以使用 final 修饰该方法。重写指的是子类重写父类方法，而重载指的是参数类型或参数数量不同。")]),a._v(" "),v("h4",{attrs:{id:"finall修饰类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finall修饰类"}},[a._v("#")]),a._v(" finall修饰类")]),a._v(" "),v("p",[a._v("final 修饰的类不能被继承。当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。"),v("strong",[a._v("为了保证某个类不可被继承，则可以使用 final 修饰这个类")]),a._v("。")]),a._v(" "),v("p",[a._v("**finall修饰类中的方法，**说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。")]),a._v(" "),v("h4",{attrs:{id:"finall与static的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finall与static的区别"}},[a._v("#")]),a._v(" finall与static的区别")]),a._v(" "),v("p",[a._v("都可以修饰类、方法、成员变量。")]),a._v(" "),v("p",[a._v("static可以修饰类的代码块，finall不可以。")]),a._v(" "),v("p",[a._v("static不可以修饰方法内局部变量，final可以。")]),a._v(" "),v("p",[a._v("static修饰表示静态或全局")]),a._v(" "),v("p",[a._v("static修饰的代码块表示静态代码块，当JVM加载类时，只会被创建一次。")]),a._v(" "),v("p",[a._v("static修饰的变量可以重新赋值")]),a._v(" "),v("p",[a._v("static方法中不能用this和super关键字。")]),a._v(" "),v("ul",[v("li",[a._v("因为this代表的是调用这个函数的对象的引用，而静态方法是属于类的，不属于对象，静态方法成功加载后， 对象还不一定存在。 this代表对本类对象的引用，指向本类已创建的对象。 super代表对父类对象的引用，指向父类对象。 静态优先于对象存在，方法被static修饰之后，方法先存在，所需的父类引用对象晚于该方法的出 现，也就是super所指向的对象还没出现，当然就会报错。")])]),a._v(" "),v("p",[a._v("static方法必须被实现，而不能是抽象的abstract")]),a._v(" "),v("p",[a._v("static方法只能被static方法覆盖")]),a._v(" "),v("p",[a._v("final修饰表示常量、一旦创建不可被修改")]),a._v(" "),v("p",[a._v("final标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可重新赋值")]),a._v(" "),v("p",[a._v("final方法不能被子类重写")]),a._v(" "),v("p",[a._v("final类不能被继承，没有子类，final类中的方法默认是final的")]),a._v(" "),v("p",[a._v("final不能用于修饰构造方法")]),a._v(" "),v("p",[a._v("private类型的方法默认是final类型的")])])}),[],!1,null,null,null);v.default=i.exports}}]);