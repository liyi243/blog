---
title: 深度spring
date: 2021-02-08 09:19:29
permalink: /pages/5c4f42/
categories:
  - 后端
  - 框架
tags:
  - 
author: 
  name: Yunzhi Li
  link: https://github.com/liyi243/liyi243.github.io
---
# 1. 开篇：这一次，让我们从小白开始

### 小伙伴的迷茫

> 我刚学完 JavaWeb 基础，接下来要学什么框架啊，感觉一头雾水。。。
>
> 我都学完 Spring 了，可感觉也只会用，稍微碰到一点问题就不会处理了。。。
>
> 看了大佬的 **《SpringBoot 源码解读与原理分析》** 小册，感觉自己根本就不会 SpringFramework ，想重新学一遍。。。

这几种言论，是我自出品《SpringBoot 源码解读与原理分析》小册之后，收到的最多的几种呼声（这种呼声在 SpringCloud  小册发布之后更多了）。确实如此，很多小伙伴都说看了原理小册，发现自己原来好多东西都没学 / 没怎么接触（诸如 SpringFramework  事件机制、后置处理器、`BeanDefinition` 等），那就更别谈深入原理了。

### SpringFramework到底有多重要

另外，还有更多的小伙伴，属于刚刚学完 JavaSE ，或者 JavaWeb 的基础知识，刚学会使用 Servlet 来开发简单的小 Web  应用。学完了基础，自然要开始接触框架了，可是框架那么多，从哪个先开始学呢？以小册编写的时间节点来看，2020年的风向，对于第一个框架的学习，大多数以推荐 MyBatis 为主，当然也有部分推荐先学习 SpringFramework 。以作者的观点，作为入门的框架，你更应该先学习  SpringFramework ，原因大致如下：

- **几乎当下所有**的企业级 JavaEE 开发**都离不开** SpringFramework ；
- SpringFramework **不局限于某一个部分** / 模块的技术，对于表现层、业务层、持久层等都有提供解决方案；
- SpringFramework 最最强大的地方在于**与其他技术的整合**，别人一开始推荐学习的 MyBatis 属于持久层解决方案，SpringFramework 能跟 MyBatis 很好地整合在一起，最终你还是得用 SpringFramework ，那为什么不先学这个中心呢？
- SpringFramework 是后续 SpringBoot 、乃至微服务 SpringCloud 的最最基础，**早早地打下基础，可以更好地为以后更高阶的技术学习铺路**；
- SpringFramework 被很多面试官拿来作为**经典面试考题**，且**难度有逐年上升的趋势**。。。

事实上，无论是国内还是国外，SpringFramework 的热度和走势一直都是特别健康的，我们可以这么说，SpringFramework 已然成为了 Java 开发的标杆、灯塔级别的“**标准**”，熟练掌握 SpringFramework ，甚至精通它，对于进军大厂，获取高薪来说是相当的有必要。

### 小册涉及的广度与深度

正如小册的名称一样，小册会带你从 SpringFramework  的小白一步一步走向大佬，自然深度不用多废话。关于广度的部分，作者收集了目前市面上和各大论坛等网站关于 SpringFramework  基础的热点，大体分为如下几个部分：IOC 、AOP 、JDBC 与事务、SpringWebMvc 和一些其他功能。其中对于 IOC  部分，展开的内容会相当多，包括容器、事件、高级特性和概念等等。

小伙伴们可以通过本小册，学习到 SpringFramework  中尽可能多而全的知识，获得知识面的广度；同时对于重点知识又能了解到它的原理，获得知识层的深度。希望能通过小册对 SpringFramework  的知识讲解，帮助小伙伴们一步一步，从小白成长为大佬，走向人生巅峰，迎娶白富美（划掉...）。

### 从小白开始吧

可能有些小伙伴对 SpringFramework 有一定的了解或者使用经验，也或者小伙伴真的就是 SpringFramework 的小白，接下来小册希望小伙伴能忘掉之前对 SpringFramework 的认识和使用经历，投入到小册中来学习吧！

# 2. 开始前的约定：关于本小册的一些前置说明

跟往常一样，咱还是有些话放在前面，小伙伴们一定要仔细阅读哦！

### 关于本小册的内容

- 小册会带你从完全不了解 SpringFramework 、完全不会使用 SpringFramework 开始，一步一步来学习，所以小伙伴不需要担心。不过，也不是什么都不会就可以学的，**最起码的 JavaSE 知识、JavaWeb 知识你得会**，**对于 Servlet 、三层架构的设计相关知识你得知道**。如果小伙伴对于这些前置知识还不太了解，小册建议你先去补足基础。
- 小册会从你熟悉的 Servlet 和三层架构开始，逐渐引导你进入 SpringFramework 的学习，所以需要小伙伴跟紧小册的思路。当然对于已经比较熟悉 SpringFramework 的小伙伴，小册同样可以**作为一本类似于“工具书”的角色**帮助你掌握某一些特定的知识。所以**无论小伙伴是初学、还是进阶，小册都非常适合你**。
- 小册目前基于 **SpringFramework 5.2.x**，当然后续的编写期间也有可能伴随 SpringFramework 5.3 的发布，**具体版本以最终小册发行时间为准**（根据官方的说法，SpringFramework 5.3 对性能有不错的提升，所以还蛮值得期待的）。
- 小册中对一些可能出现混淆意义的概念作了更清晰的概念处理（如普遍意义上开发中称呼的 Spring 一般都是 **SpringFramework** ，故本小册中提到的所有 Spring 基础框架统称 SpringFramework）。
- 小册在进阶和高级等部分的讲解中可能会引用 SpringFramework 中源码的 javadoc ，对于这些出现的文档注释，小册统一使用**原文 + 翻译**的方式，这样做的目的是**保留原作者想表达的原汁原味的东西**，而不是直接贴上我的翻译，**人的翻译总是会带入一些个人的主观色彩，会影响原文内容的理解**。小伙伴们在看文档注释的时候可以结合原文和小册的翻译注释来看，可以更助于理解。

### 关于本小册的作者

- 作者不是什么专业大佬，大厂P8P9之类的，也没什么高端的职称，只是喜欢深扒原理，了解底层的东西（已读过很多框架的源码，包括出版  SpringBoot 、SpringCloud  源码分析）。所以喜欢作者头衔是什么什么架构师，什么大厂高级工程师，几十年工作经验的童鞋们请三思￣へ￣。
- 在作者看来，学习一门技术，想要从入门到熟悉，再到进阶、掌握，最终冲刺高级和原理，这是一个循序渐进的过程，这个过程最好跟着一个既定的主线走，可以减少一些不必要的额外的成本。作者也在不断思考和改进小册的设计，如何做到能更容易的学习新的技术，或者加强已经学过的技术。有主意的小伙伴可以多多帮作者支招啊，不胜感激。

### 关于阅读小册的几点建议

- 小册都是用 Markdown 语法编写，**PC、平板电脑的阅读效果会更好一些**。小册中对于代码编写、框架源码的粘贴部分可能很大很宽，如果用手机阅读需要频繁左右滑动，暂且先不说阅读内容和收获，首先从时间上你就多余的浪费了不少，而且不容易连贯的阅读。
- 如果小伙伴是刚开始学 SpringFramework 的话，强烈建议从头开始按顺序往下看，因为**进阶和高级的部分通常会依赖基础部分的讲解**，所以，不要 “没学会走就想着跑，甚至飞” 。
- 小册里讲解的知识，以及高级和原理部分的剖析，我都会尽可能写的明白，但写得明白终究是我觉得明白，以及部分人的明白。如果小伙伴在阅读小册时发现有困惑或者疑问，最好是去群里问问题嗷，只要是我能帮的我都尽可能的帮。

### 关于IDE、环境和源码

- 不得不说，**IDEA** 的强大真的比 eclipse 高出太多了，它不仅仅是强大，更是**智慧、聪明的 IDE** 。一个聪明的 IDE ，可以帮助小伙伴在学习时减少一些不必要的错误，所以作者在这里**强烈建议小伙伴使用 IDEA 学习 SpringFramework** 。
- 对于环境和工程的搭建，我不打算在整个学习过程中使用任何普通的工程构建，而是**全部基于 Maven 构建**。作为一个**项目构建和管理工具**，它可以帮助开发者维护项目中使用的依赖，省去很多之前构建普通工程时导 jar 包不全，以及版本不匹配的问题。当然如果小伙伴使用 **Gradle** 构建项目也是完全可以的，二者选其一即可。
- 所以，如果小伙伴使用如下的开发环境，那么你可以非常愉快的跟着小册来学习 SpringFramework 啦：
  - jdk 1.8 + ( Maven 3.3.9 / Gradle 4.0 ) 或更高版本
  - IDEA（作者目前使用的是 2019.1 ）
- 本小册中讲解的所有示例源码均可从 GitHub 上找到：[github.com/LinkedBear/…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLinkedBear%2Fspring-framework-learning-code)

### 补充几句

- 作者是人，不是神仙，不能完全 100% 保证小册中没有问题。如果小伙伴们发现了小册中出现错误和准确性问题，请通过群及时联系我，我会及时尽快的修改订正的。
- 小伙伴们可以多多在小册评论区留言，或者加群咱们一起讨论！

# 3.入门-IOC是怎么来的

好了咱开始进入正题了，在开始学习 SpringFramework 之前，咱先看一个场景。

【小伙伴最好设身处地的代入本章的场景中，这样更有利于体会 IOC 的由来，也更容易理解】

## 1. 原生Servlet时代的三层架构

下面咱实际动手搭建一个在原生 Servlet 时代的 MVC 三层架构的工程，以此为背景板。

（为方便后续内容演示，使用 IDEA 创建工程前，先创建一个空工程 `spring-framework-projects` ，用来存放接下来的所有工程）

### 1.1 构建基于Maven的原生Servlet工程

使用 Maven 构建项目那是最基本的能力了，咱使用 IDEA 快速搭建一个原生的 Servlet 工程。

pom 依赖中，只需要引入 Servlet 的 api 即可：（此处我使用了 Servlet3.1 ，这个倒是无所谓，只是用 **Servlet3.0+** 的版本可以基于注解开发，效率较快）

```xml
<dependencies>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
```

当然，为了使工程的编译级别在 1.8 级别，还需要加入 Maven 的编译插件：（版本不要太老就好，此处我选用 3.2 版本）

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.2</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
```

最后，不要忘记调整打包方式为 war 包：

```xml
<packaging>war</packaging>
```

### 1.2 将工程部署到Servlet容器

创建好工程后，下一步先不要着急写代码，咱先把工程部署到 Servlet 容器中，保证能正常运行。这里咱使用 Tomcat 作为 Servlet 容器来运行工程。

在 IDEA 中依次打开 **“File -> Project Structure”** ，选中 **Artifacts** 标签，并添加 **Web Application: Exploded** 类型的输出类型，配置好对应的路径与名称，即可设置好编译打包输出配置。如下图所示：

![img](./assets/d95d13e9fe1d48cd98c4dd9e5602e037~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

接下来，在 IDEA 的运行栏中选择 **Add Configuration...** ，并添加本地的 Tomcat ：

![img](./assets/31aa147ff1cb4f56be12b111861c7306~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

接下来在新建的 Tomcat 中选择 **Deployment** ，并添加刚配置好的 **Artifact** ：

![img](./assets/14ac30da10b84813be0abbadbe6f83b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

添加完成后，即可保存确定。

### 1.3 编写Servlet测试可用

在 `src/main/java` 中新建一个 `DemoServlet` ，标注 `@WebServlet` 注解，并继承 `HttpServlet` ，重写 `doGet` 方法：

```java
@WebServlet(urlPatterns = "/demo1")
public class DemoServlet1 extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.getWriter().println("DemoServlet1 run ......");
    }
    
}
```

编写完毕后直接启动 Tomcat ，此时 IDEA 会自动编译工程并部署到 Tomcat 中。

打开浏览器，地址栏输入 [http://localhost:8080/spring_00_introduction_architecture/demo1](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8080%2Fspring_00_introduction_architecture%2Fdemo1) （每个人搭建的工程名可能不一致，context-path 记得修改），发现可以正常打印 `DemoServlet1 run ......` 的输出，证明工程搭建并配置成功。

### 1.4 编写Service与Dao

因为一开始 pom 中没有导入与数据库相关的依赖，故此处的 Dao 只是空壳，并没有实际的 jdbc 相关操作。

在工程目录下新建以下几个类和接口，这些都是老生常谈了，都很简单：

![img](./assets/9e316ba2558a4c36ae32d473cf4e63df~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

对应的三层架构中的组件及依赖就应该是这样：（ Dao 连接数据库的部分不实现）

![img](./assets/bd19682e7682438fb4ddd1460342ac23~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 1.4.1 Dao与DaoImpl

简单定义一个 `DemoDao` 接口，并声明一个 `findAll` 方法模拟从数据库查询一组数据：

```java
public interface DemoDao {
    List<String> findAll();
}
```

编写它对应的实现类 `DemoDaoImpl` ，由于没有引入数据库的相关驱动，故这里只是用写死的临时数据模拟 Dao 与数据库的交互：

```java
public class DemoDaoImpl implements DemoDao {
    
    @Override
    public List<String> findAll() {
        // 此处应该是访问数据库的操作，用临时数据代替
        return Arrays.asList("aaa", "bbb", "ccc");
    }
}
```

至此，Dao 层的接口与实现类定义完成。

#### 1.4.2 Service与ServiceImpl

编写一个 `DemoService` 接口，并声明 `findAll` 方法：

```java
public interface DemoService {
    List<String> findAll();
}
```

编写它对应的实现类 `DemoServiceImpl` ，并在内部依赖 `DemoDao` 接口：

```java
public class DemoServiceImpl implements DemoService {
    
    private DemoDao demoDao = new DemoDaoImpl();
    
    @Override
    public List<String> findAll() {
        return demoDao.findAll();
    }
}
```

至此，Service 层的接口与实现类定义完成。

### 1.5 修改DemoServlet

由于要模拟整体的三层架构，故 `DemoServlet1` 要依赖 `DemoService` ：

```java
@WebServlet(urlPatterns = "/demo1")
public class DemoServlet1 extends HttpServlet {
    
    DemoService demoService = new DemoServiceImpl();
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().println(demoService.findAll().toString());
    }
}
```

### 1.6 重新运行应用并测试可用

重新部署到 Tomcat 并运行，访问 `/demo1` 路径，浏览器中会打印 `['aaa', 'bbb', 'ccc']` ，说明编写正确且运行正常。

------

以上部分是咱在 JavaWeb 基础中最熟悉不过的东西了，好了到这里咱停下来，代入一个场景。

## 2. 【问题】需求变更

现在你的手头上已经基本上开发完成了，数据库用的 MySQL 很舒服，临近交付项目，客户一个电话打过来了：

> 哎呦我去这瞧谁不起啊？我可是大老板，给老子换 Oracle 的数据库！

挂掉电话的你内心一万只草泥马呼啸而去：

![img](./assets/ab8314215cb14837a4f6baed5e7d3bcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

没招啊，客户是上帝啊，咱也是要恰饭的嘛，客户要啥咱就得改啥啊！那改吧：

### 2.1 修改数据库

咱都知道，对于 MySQL 跟 Oracle ，在有一些**特定的 SQL 上是不一样的**（比如分页），这样我还不能只把数据库连接池的相关配置改了就好使，每个 DaoImpl 也得改啊！于是乎，你开始修改起工程里所有的 DaoImpl ：

```java
public class DemoDaoImpl implements DemoDao {
    
    @Override
    public List<String> findAll() {
        // 模拟修改SQL的动作
        return Arrays.asList("oracle", "oracle", "oracle");
    }
}
```

### 2.2 需求再次变更

你好不容易熬夜两个晚上，头发掉了一把又一把，终于要给客户部署工程了，客户笑眯眯的跟你说了一句话：

> 那个啥，最近炒股。。。呃不是，财务支出有点严重，这不有点囊中羞涩，数据库就换回 MySQL 吧！

此时的你一定是：

![img](./assets/6c2134037635436493b6ad12aa4043d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

你已经受够了这种改过来改过去的破事了，毕竟狗命要紧（杀死程序猿最简单的办法：改三次需求），那这个时候你就得想啊，怎么解决这个问题呢？

### 2.3 【方案】引入静态工厂

苦思良久，你终于想到了一个好办法：如果我**事先把这些 Dao 都写好**了，之后**用一个静态工厂来创建特定类型的实现类**，这样万一发生需求变更，是不是就可以做到只改一次代码就可以了！

于是按照这个想法，有如下改造：

#### 2.3.1 构造静态工厂

声明一个静态工厂，起个比较别致的名字吧：`BeanFactory` （不要问我为什么这么别致，这是一个伏笔）

```java
public class BeanFactory {
    public static DemoDao getDemoDao() {
        // return new DemoDaoImpl();
        return new DemoOracleDao();
    }
}
```

#### 2.3.2 改造ServiceImpl

ServiceImpl 中引用的 Dao 不再是手动 new ，而是由 `BeanFactory` 的静态方法返回而得：

```java
public class DemoServiceImpl implements DemoService {
    
    DemoDao demoDao = BeanFactory.getDemoDao();
    
    @Override
    public List<String> findAll() {
        return demoDao.findAll();
    }
}
```

如此这般，即便 ServiceImpl 再多，Dao 再多，**发生需求更改**，我也**只需要改动 BeanFactory 中的静态方法返回值即可**！

问题解决，皆大欢喜，客户也很满意，项目交付完成。

## 3. 【问题】源码丢失

项目上线运行一段时间后，客户对系统中的一些功能提出了优化和扩展需求，那这个时候你就来维护呗，毕竟你最熟悉这个项目。不过之前好一段时间你都去负责别的项目去了，维护工作都是由你同事负责着。

当你重新打开工程时，想先拉起来看看要扩展的需求具体的位置，居然发现项目连编译都无法通过了！（为演示无法编译的现象，删除 `DemoDaoImpl.java` ）

此时的你肯定是一脸黑人问号啊！怎么之前好使的现在就不好使了？再仔细一看报错位置，`BeanFactory` ！哎不大对劲啊，我这之前封装好的静态工厂就是偷懒用的，怎么会编译出错呢？打开代码看了一眼才知道，合着少了一个 `DemoDaoImpl` 的源文件，导致代码根本无法编译了！

场景演绎到这里，咱先稍微暂停一下，体会一下这里面出现的问题。

### 3.1 【概念】类之间的依赖关系——紧耦合

```java
public class BeanFactory {
    public static DemoDao getDemoDao() {
        return new DemoDaoImpl(); // DemoDaoImpl.java不存在导致编译失败
    }
}
```

当前的代码中，因为源码中真的缺少这个 `DemoDaoImpl` 类，导致编译都无法通过，这种现象就可以描述为 **“ `BeanFactory` 强依赖于 `DemoDaoImpl` ”** ，也就是咱可能听过也可能常说的“**紧耦合**”。

### 3.2 【方案】解决紧耦合

回到刚才的场景中，你这直接懵逼了呀，没有这个 .java 文件，我没法编译，那我不用干活了呗？不行，咱可不能因为这个问题就耽误了整体呀！于是乎你开动脑筋，想一下在现有知识中，有没有一种办法能解决这个编译都没办法编译的问题？

**反射！反射可以声明一个类的全限定名，来获取它的字节码描述，这样也能构造对象！**

于是 `BeanFactory` 可以改造为：

```java
public class BeanFactory {
    
    public static DemoDao getDemoDao() {
        try {
            return (DemoDao) Class.forName("com.linkedbear.architecture.c_reflect.dao.impl.DemoDaoImpl").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("DemoDao instantiation error, cause: " + e.getMessage());
        }
    }
}
```

照这样一写，是不是编译的问题就解决了？尽管在 `DemoService` 的初始化时还是会出现问题，但最起码可以把项目拉起来了啊！

于是这个问题就暂时解决了，先放一边了。。。

### 3.3 【概念对比】弱依赖

使用反射之后，错误现象不再是在编译器就出现，而是在工程启动后，由于 `BeanFactory` 要构造 `DemoDaoImpl` 时确实还没有该类，所以抛出 `ClassNotFoundException` 异常。这样 **`BeanFactory` 对 `DemoDaoImpl` 的依赖程度**就相当于**降低**了，也就可以算作“**弱依赖**”了。

## 4. 【问题】硬编码

躲得了初一躲不了十五，这个问题最终还是得解决，你费劲八道的终于把 `DemoDaoImpl.java` 找了回来，这下终于运行期也不报错了。但这样在切换 MySQL 和 Oracle 库时还是会出现一个问题：由于类的全限定名是写死在 `BeanFactory` 的源码中，导致每次切换数据库后还得重新编译工程才可以正常运行，这显得貌似很没必要，应该有更好的处理方案。

### 4.1 【改良】引入外部化配置文件

机智的你利用现有的 JavaSE 知识，立马能想到：哎，我可以**借助 IO 来实现文件存储配置**啊！这样**每次 `BeanFactory` 被初始化时，让它去读配置文件，这样就不会出现硬编码的现象了**！

于是可有如下改造：

#### 4.1.1 加入factory.properties文件

在 `src/main/resource` 目录下新建 `factory.properties` 文件，并在其中声明如下内容：

```properties
demoService=com.linkedbear.architecture.d_properties.service.impl.DemoServiceImpl
demoDao=com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl
```

为了方便回头取这些类的全限定名，我**给每一个类名都起一个“小名”**（别名），这样我就可以**根据小名来找到对应的全限定类名**了。

#### 4.1.2 改造BeanFactory

既然配置文件是 properties 类型，在 jdk 中刚好也有一个 API 叫 `Properties` ，它可以解析 `.properties` 文件。

于是可以在 `BeanFactory` 中加入一个静态变量：

```java
public class BeanFactory {
    
    private static Properties properties;
```

下面要在工程刚启动的时候就初始化 `Properties` ，这咱可以使用静态代码块实现吧：

```java
    private static Properties properties;
    
    // 使用静态代码块初始化properties，加载factord.properties文件
    static {
        properties = new Properties();
        try {
            // 必须使用类加载器读取resource文件夹下的配置文件
            properties.load(BeanFactory.class.getClassLoader().getResourceAsStream("factory.properties"));
        } catch (IOException e) {
            // BeanFactory类的静态初始化都失败了，那后续也没有必要继续执行了
            throw new ExceptionInInitializerError("BeanFactory initialize error, cause: " + e.getMessage());
        }
    }
```

配置文件读取到之后，下面的 `getDao` 方法也可以进一步改了：

```java
    public static DemoDao getDemoDao() {
        try {
            Class<?> beanClazz = Class.forName(properties.getProperty("demoDao"));
            return beanClazz.newInstance();
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("BeanFactory have not [" + beanName + "] bean!", e);
        } catch (IllegalAccessException | InstantiationException e) {
            throw new RuntimeException("[" + beanName + "] instantiation error!", e);
        }
    }
```

写到这里，是不是感觉怪怪的。。。都抽象化到这种地步了，还有必要在这里面写死 “demoDao” 吗？肯定没必要了吧，干脆做一个通用得了，你传什么别名，`BeanFactory` 就从配置文件中找对应的全限定类名，反射构造对象返回：

```java
    public static Object getBean(String beanName) {
        try {
            // 从properties文件中读取指定name对应类的全限定名，并反射实例化
            Class<?> beanClazz = Class.forName(properties.getProperty(beanName));
            return beanClazz.newInstance();
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("BeanFactory have not [" + beanName + "] bean!", e);
        } catch (IllegalAccessException | InstantiationException e) {
            throw new RuntimeException("[" + beanName + "] instantiation error!", e);
        }
    }
```

#### 4.1.3 改造ServiceImpl

`DemoServiceImpl` 中不再需要调 `getDao` 方法了（因为被删了...），而是转用 `getBean` 方法，并指定需要获取的指定名称的类的对象：

```java
public class DemoServiceImpl implements DemoService {
    
    DemoDao demoDao = (DemoDao) BeanFactory.getBean("demoDao");
```

到这里，你突然发现一个现象：这下你可以把**所有**想抽取出来的**组件都可以做成外部化配置**了！

### 4.2 【思想】外部化配置

对于这种可能会变化的配置、属性等，通常不会直接硬编码在源代码中，而是抽取为一些配置文件的形式（ properties 、xml 、json 、yml 等），配合程序对配置文件的加载和解析，从而达到动态配置、降低配置耦合的目的。

## 5. 【问题】多重构建

改到这里可能你会感觉，是不是哪里不对劲，是不是还有改进的空间呢？这样，咱在 `ServiceImpl` 的构造方法中连续多次获取 `DemoDaoImpl` ：

```java
public class DemoServiceImpl implements DemoService {
    
    DemoDao demoDao = (DemoDao) BeanFactory.getBean("demoDao");
    
    public DemoServiceImpl() {
        for (int i = 0; i < 10; i++) {
            System.out.println(BeanFactory.getBean("demoDao"));
        }
    }
```

咱只来看打印的这些 `DemoDao` 的内存地址：

```kotlin
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@44548059
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@5cab632f
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@24943e59
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@3f66e016
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@5f50e9eb
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@58e55b35
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@5d06d086
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@55e8ed60
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@daf5987
com.linkedbear.architecture.d_properties.dao.impl.DemoDaoImpl@7f6187f4
```

可以发现每次打印的内存地址都不相同，证明是创建了10个不同的 `DemoDaoImpl` ！但是，真的有必要吗。。。

### 5.1 【改良】引入缓存

如果对于这些没必要创建多个对象的组件，如果能有一种机制保证整个工程运行过程中只存在一个对象，那就可以大大减少资源消耗。于是可以在 `BeanFactory` 中加入一个缓存区：

```java
public class BeanFactory {
    // 缓存区，保存已经创建好的对象
    private static Map<String, Object> beanMap = new HashMap<>();
    
    // ......
```

之后在 `getBean` 方法中，为了控制线程并发，需要引入双检锁保证对象只有一个：

```java
public static Object getBean(String beanName) {
    // 双检锁保证beanMap中确实没有beanName对应的对象
    if (!beanMap.containsKey(beanName)) {
        synchronized (BeanFactory.class) {
            if (!beanMap.containsKey(beanName)) {
                // 过了双检锁，证明确实没有，可以执行反射创建
                try {
                    Class<?> beanClazz = Class.forName(properties.getProperty(beanName));
                    Object bean = beanClazz.newInstance();
                    // 反射创建后放入缓存再返回
                    beanMap.put(beanName, bean);
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException("BeanFactory have not [" + beanName + "] bean!", e);
                } catch (IllegalAccessException | InstantiationException e) {
                    throw new RuntimeException("[" + beanName + "] instantiation error!", e);
                }
            }
        }
    }
    return beanMap.get(beanName);
}
```

改良完成，重新测试，观察这一次打印的结果：

```kotlin
com.linkedbear.architecture.e_cachedfactory.dao.impl.DemoDaoImpl@4a667700
com.linkedbear.architecture.e_cachedfactory.dao.impl.DemoDaoImpl@4a667700
com.linkedbear.architecture.e_cachedfactory.dao.impl.DemoDaoImpl@4a667700
......
```

果然只会有一个对象了，最终目的达到。

------

到这里，整个场景的演绎就算结束了，下面咱来总结一下这里面出现的几个关键点。

- 静态工厂可将多处依赖抽取分离
- 外部化配置文件+反射可解决配置的硬编码问题
- 缓存可控制对象实例数

接下来，是时候引出这一章的主题了。

## 6. IOC的思想引入【重点】

对比上面的两种代码写法：

```java
private DemoDao dao = new DemoDaoImpl();

private DemoDao dao = (DemoDao) BeanFactory.getBean("demoDao");
```

上面的是强依赖 / 紧耦合，在编译期就必须保证 `DemoDaoImpl` 存在；下面的是弱依赖 / 松散耦合，只有到运行期反射创建时才知道 `DemoDaoImpl` 是否存在。

再对比看，上面的写法是主动声明了 `DemoDao` 的实现类，只要编译通过，运行一定没错；而下面的写法没有指定实现类，而是由 `BeanFactory` 去帮咱查找一个 name 为 `demoDao` 的对象，倘若 `factory.properties` 中声明的全限定类名出现错误，则会出现强转失败的异常 `ClassCastException` 。

仔细体会下面这种对象获取的方式，本来咱开发者可以使用上面的方式，主动声明实现类，但如果选择下面的方式，那就不再是咱自己去声明，而是**将获取对象的方式交给了 `BeanFactory`** 。这种**将控制权交给别人**的思想，就可以称作：**控制反转（ Inverse of Control , IOC ）**。而 `BeanFactory` 根据指定的 `beanName` 去获取和创建对象的过程，就可以称作：**依赖查找（ Dependency Lookup , DL ）**。

## 小结与思考

【每一章的最后，我会留下一些小问题和小练习，帮助小伙伴回顾本章的内容，加深印象】

1. 需求变更引起的工程代码变动成本是巨大的，有什么办法可以减少变动成本呢？
2. 如何理解控制反转？

【终于了解什么是 IOC ，以及它的实现方式之一：**依赖查找**。下面咱就可以真正的快速入门 SpringFramework 了】

# 4. 入门-SpringFramework概述与IOC的依赖查找

了解了 IOC 的由来，接下来咱就可以真正的开始学习 SpringFramework 了。首先咱先对 SpringFramework 有一个大概的了解，毕竟学习一项技术，首先要知道它是什么、它都有什么、它能干什么等等。

## 1. SpringFramework概述【了解】

【以下内容可能比较啰里八嗦，想直接拿来面试的小伙伴请直接移步 1.4 节】

### 1.1 官方网站主页

引用官方网站主页的说明，Spring 官方对 SpringFramework 的描述是这样的：

[spring.io/projects/sp…](https://link.juejin.cn?target=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-framework)

> The Spring Framework provides a comprehensive programming and  configuration model for modern Java-based enterprise applications - on  any kind of deployment platform.
>
> A key element of Spring is infrastructural support at the application level: Spring focuses on the "plumbing" of enterprise applications so  that teams can focus on application-level business logic, without  unnecessary ties to specific deployment environments.
>
> Spring 框架为**任何类型的部署平台**上的**基于 Java** 的现代**企业应用程序**提供了全面的**编程和配置模型**。
>
> Spring 的一个关键元素是在**应用程序级别的基础架构支持**：Spring 专注于企业应用程序的 “**脚手架**” ，以便团队可以**专注于应用程序级别的业务逻辑**，而不必与特定的部署环境建立不必要的联系。

这段描述的内容只能用一个词概括：要素过多！对这里面的一些概念作一些解释，方便咱更好地理解这段话。

- 任何类型的部署平台：无论是操作系统，还是 Web 容器（ Tomcat 等）都是可以部署基于 SpringFramework 的应用
- 企业应用程序：包含 JavaSE 和 JavaEE 在内，它被称为一站式解决方案
- 编程和配置模型：基于框架编程，以及基于框架进行功能和组件的配置
- 基础架构支持：SpringFramework 不含任何业务功能，它只是一个底层的应用抽象支撑
- 脚手架：使用它可以更快速的构建应用

想必理解了这些关键概念的意思，也就更容易理解 SpringFramework 的强大了吧！

### 1.2 官方文档

上面看到的只是官方网站的 SpringFramework 工程首页的介绍概述，进入到 5.2 版本的官方文档中，这里面也有一段解释：

[docs.spring.io/spring/docs…](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring%2Fdocs%2F5.2.x%2Fspring-framework-reference%2Foverview.html%23overview)

> Spring makes it easy to create Java enterprise applications. It  provides everything you need to embrace the Java language in an  enterprise environment, with support for Groovy and Kotlin as  alternative languages on the JVM, and with the flexibility to create  many kinds of architectures depending on an application’s needs.
>
> Spring 使创建企业级 Java 应用程序变得容易。它提供了在企业环境中使用Java语言所需的一切，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种体系结构。

这个描述算是更为概括和笼统吧，它同样解释了 SpringFramework 的强大和使用范围之广，另外它还提了一嘴 “运行在 JVM 上的第二语言”，这些东西咱可能很陌生，那就先不看它了。

下面小册整理一些网络上流传的比较多的 SpringFramework 概述。

### 1.3 网络流传概述

- SpringFramework 是一个分层的、JavaSE / JavaEE 的一站式轻量级开源框架，以 IOC 和 AOP 为内核，并提供表现层、持久层、业务层等领域的解决方案，同时还提供了整合第三方开源技术的能力。
- SpringFramework 是一个 JavaEE  编程领域的轻量级开源框架，它是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架。SpringFramework  是一个容器框架，它集成了各个类型的工具，通过核心的 IOC 容器实现了底层的组件实例化和生命周期管理。
- SpringFramework 是一个开源的容器框架，核心是 IOC 和 AOP ，它为了简化企业级开发而生。SpringFramework 有诸多优良特性（非侵入、容器管理、组件化、轻量级、一站式等）。

观察这些概述，对比官方文档中的描述，可以额外的提取出几个关键词：

- IOC & AOP：SpringFramework 的两大核心特性：**Inverse of Control 控制反转、Aspect Oriented Programming 面向切面编程**
- 轻量级：对比于重量级框架，它的规模更小（可能只有几个 jar 包）、消耗的资源更少
- 一站式：覆盖企业级开发中的所有领域
- 第三方整合：SpringFramework 可以很方便的整合进其他的第三方技术（如持久层框架 MyBatis / Hibernate ，表现层框架 Struts2 ，权限校验框架 Shiro 等）
- 容器：SpringFramework 的底层有一个管理对象和组件的容器，由它来支撑基于 SpringFramework 构建的应用的运行

好了，有了这些概述，最终咱需要提取出一个能尽可能表述完整且精简的概述。

### 1.4 【面试题】面试中如何概述SpringFramework

以下答案**仅供参考**，可根据个人理解和知识储备进行实际调整：

**SpringFramework 是一个开源的、松耦合的、分层的、可配置的一站式企业级 Java 开发框架，它的核心是 IOC 与 AOP ，它可以更容易的构建出企业级 Java 应用，并且它可以根据应用开发的组件需要，整合对应的技术。**

解释下这样概括的要点：

- 加入 “**松耦合**” 的概念是为了描述 IOC 和 AOP ，如果面试继续问 IOC 或耦合相关的内容，那这部分就可以拿去做回应
- 加入 “**可配置**” 是为了给 SpringBoot 垫底（可能还没到这一步，不过现在记住就好啦，后续会讲的）
- IOC 和 AOP 可提可不提，毕竟你只要学了它就肯定知道（人家 Spring 官方都懒得提它。。。）
- 没有提 “轻量级” ，是考虑到现在的大环境趋势早已经没有 EJB 的身影了（EJB是什么东西下面就会提到）
- 没有提 “容器” 的概念，是因为 SpringFramework 不仅仅是一个容器，如果只是限定死容器那相当于说窄了
- 注意对比 “企业级Java开发” 与 “JavaEE开发” 的区别：SpringFramework 不仅能构建在 Web 项目，对于普通的 JavaSE 项目、GUI 项目，也是可以用 SpringFramework 的

------

那既然说要学 SpringFramework ，为啥我就非得要学它啊？它凭什么值得我学呢？

## 2. 为什么使用SpringFramework【重点，面试题】

通过上面对 SpringFramework 的概述，想必也能总结出一些优点和强大之处：

【以下内容可用于面试题】

- **IOC**：组件之间的解耦（咱上一章已经体会到了）
- **AOP**：切面编程可以将应用业务做统一或特定的功能增强，能实现应用业务与增强逻辑的解耦
- **容器**与事件：管理应用中使用的组件Bean、托管Bean的生命周期、事件与监听器的驱动机制
- Web、事务控制、测试、与**其他技术的整合**

可能大多数的条目看上去还是不太容易能理解的，咱先看一眼，脑海里有个印象就可以了。随着深入的学习，这些内容会慢慢的被你理解。

------

要知道一点：学习一门技术，不要知道是什么就立马开始，一些背景还是要稍微了解一下的，了解背景可以为后面的学习作一些信息支撑。

## 3. SpringFramework的发展历史【了解】

聊到 SpringFramework 的发展历史，这里面的故事蛮有意思的，给小伙伴们讲讲那当年的故事。小伙伴大概知道有这么回事就行，没必要记住具体的内容，咱讲这部分也就图一乐。

### 3.1 EJB思想的提出

这个事得说回上个世纪的 1997 年，IBM 公司咱都知道，老大哥了是吧。人家那里头的大佬多啊，面对当时的 J2EE 开发，为了整一套标准的 Java 扩展开发，IBM 的大佬们费心研究，提出了一个技术思想：**EJB** ( Enterprise JavaBean ) ，并且还扬言说，做企业级开发就得按照我说的这么来！按照我这样做是标准的、规范的！

### 3.2 EJB的诞生与程序猿的痛苦

提出 EJB 来之后，这个思想被 Sun （那个时候 Java 还是 Sun 的）看到了，呦呵你这个东西好啊，那我是 Java  他爹啊，你这思想我能给你整合进来，壮大咱 Java 的规模和势力啊。于是在 1998 年，Java 中就有了 EJB 的标准规范，它跟当时  J2EE 的其它技术一起联合（包括 JMS 消息、JNDI 命名目录接口、JSP 服务端页面技术等等），称之为 J2EE  开发的核心技术。随后，IBM 召集的这群大佬就把 EJB 的实现给造出来了，而且在 2002 年 EJB 出了 2.0 版，那个时候基本上  EJB 已经可以横行 J2EE开发了，大家都拿 EJB 当做企业级开发的标准。

不过 EJB 虽然很牛，但学起来实在是太麻烦了，而且它本身是个重量级的技术，与应用业务的代码侵入度实在是有点高，所以搞得大家用 EJB  的时候都好痛苦。但话又说回来，人家 IBM 那么多大佬提出来、实现好的技术，你一句难学、不好用就行了？那是不是你本身太笨了才搞得你学不会呢？

![img](./assets/200107f1d6a345b284a9847814d5c97a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

也由于这个原因吧，当时的 J2EE 开发者们都是一边嘟囔着难用难学，但又不好说出来，只能含泪使用。

### 3.3 SpringFramework的诞生

既然大家都用，难免会有一些铁头娃，人家就是觉得，**你不好用还赖得着我脑子笨？你不好用大家还都就变成猪头了？** 于是，一个伟大的神仙级人物要登场了。(bgm......)

时间到了 2002 年，有一个人叫 **Rod Johnson** ，他写了一本书：**《Expert One-on-One J2EE design and development》** ，里面对当时现有的 J2EE 应用的架构和框架存在的臃肿、低效等问题提出了质疑，并且积极寻找和探索解决方案。大概的意思就是说，“我觉得 J2EE 开发挺好的，就是特喵的有些迷惑的设计实在是，徒增成本，方向错了”。

过了 2 年，2004 年 SpringFramework 1.0.0 横空出世，随后 **Rod Johnson** 又写了一本书，当时在 J2EE 开发界引起了巨大轰动，它就是著名的 **《Expert one-on-one J2EE Development without EJB》**，这本书中直接告诉开发者完全可以不使用 EJB 开发 J2EE 应用，而是可以换用一种更轻量级、更简单的框架来代替，那就是 **SpringFramework** 。

这本书一出来，开发圈都是这样的：

![img](./assets/393b0760c88047119410ce83e31a90e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

你一个毛头小子还敢质疑 IBM 诸多大佬的设计精华？这么狂不怕被揍吗？但是！人的四大本质之一 ———— **真香怪**。后来开发界的程序猿们用了 SpringFramework 感觉确实比 EJB 好，而且 SpringFramework 提供的一些特性也比 EJB 好，于是大家就慢慢转投 SpringFramework 了。

### 3.4 SpringFramework的版本迭代

下面咱列出一个 SpringFramework 的重要版本更新时间及重大特性，现阶段小伙伴们可以只是看一眼，后面咱讲到具体的内容时都会提及到。

| SpringFramework版本 | 对应jdk版本 | 重要特性                                                     |
| ------------------- | ----------- | ------------------------------------------------------------ |
| SpringFramework 1.x | jdk 1.3     | 基于 xml 的配置                                              |
| SpringFramework 2.x | jdk 1.4     | 改良 xml 文件、初步支持注解式配置                            |
| SpringFramework 3.x | Java 5      | 注解式配置、JavaConfig 编程式配置、Environment 抽象          |
| SpringFramework 4.x | Java 6      | SpringBoot 1.x、核心容器增强、条件装配、WebMvc 基于 Servlet3.0 |
| SpringFramework 5.x | Java 8      | SpringBoot 2.x、响应式编程、SpringWebFlux、支持 Kotlin       |

## 4. SpringFramework包含的模块【熟悉，面试题】

大致了解一下 SpringFramework 的核心模块，以及包含的技术，混个脸熟。

【以下内容可用于面试题】

- beans、core、context、expression 【核心包】
- aop 【切面编程】
- jdbc 【整合 jdbc 】
- orm 【整合 ORM 框架】
- tx 【事务控制】
- web 【 Web 层技术】
- test 【整合测试】
- ......

------

好了，啰里八嗦了那么多，下面咱终于可以动手操作啦！冲冲冲！

## 5. 快速入门-IOC-DL【掌握】

下面咱用一个最最简单的实例，来体会 SpringFramework 中对于依赖查找的使用。

### 5.1 引入依赖

对于快速入门阶段来讲，咱只需要引入一个依赖即可：`spring-context` （此处引入的版本是 5.2.8 ）

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.8.RELEASE</version>
</dependency>
```

### 5.2 创建配置文件

像前面咱推演出来的规矩差不多，SpringFramework 实现 IOC 可以借助配置文件的方式来描述类和对象的定义信息。在工程的 `resources` 目录下，咱创建一个 `quickstart-byname.xml` 文件（为了使配置文件的存放更具条理，且容易维护，咱提前创建好一个文件夹）：

![img](./assets/16f6e60f6a3545dfa612f73ffea1c6a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这里面的初始内容是预先规定好的，从 SpringFramework 的官方文档中可以找到 xml 配置文件的空架子：[docs.spring.io/spring/docs…](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring%2Fdocs%2F5.2.x%2Fspring-framework-reference%2Fcore.html%23beans-factory-instantiation)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>
```

将这段内容粘贴到 `quickstart-byname.xml` 中即可。

### 5.3 [可选] 配置IDEA项目工程中的应用上下文

小伙伴们可能注意到了，粘贴了上面这段 xml 后，IDEA 会弹出一段提示：

![img](./assets/11788d98750a44ae842d1a8811424e3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

由此可见 IDEA 是多么的智能，它意识到你要在工程中添加 SpringFramework 的配置文件，它就想让你把这个配置文件配置到 IDEA 的项目工作环境下，那咱只需要按照提示，点击 `Configure application context` ，随后点击 `Create new application context...` ，会弹出一个对话框，让你创建应用上下文：

![img](./assets/02316f3b83f14bdb9ad7c30b6778548c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

啥也不用管，直接点 OK ，就完事了。此番动作是让 IDEA 也知道，咱在使用 SpringFramework 开发应用，IDEA 会自动识别咱写的配置，可以帮我们省很多心。

### 5.4 声明一个普通的类

由于我的 `src/main/java` 中创建的包结构是按照咱小册的章节划分的，小伙伴们可以根据自己的习惯和喜好，划分包结构。下面我在咱这一小节的 `com.linkedbear.spring.basic_dl.a_quickstart_byname` 包下创建一个 bean 包，随后创建一个 `Person` 类：

![img](./assets/5a2f941385e14ff3a8da60d21ff0bf21~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

创建好就可以放那儿了，也不用在里面写这写那的。

### 5.5 在配置文件中加入Person声明

在 `quickstart-byname.xml` 中，使用 SpringFramework 的定义规则，将 `Person` 声明到配置文件中：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="person" class="com.linkedbear.spring.basic_dl.a_quickstart_byname.bean.Person"></bean>
</beans>
```

可以看到声明的规则很简单，跟之前咱写的 properties 形式几乎一个意思，也是 key 和 value ，只不过这里分别对应的是 id 和 class 罢了。

这么写完之后 IDEA 会报 xml 标签体为空，根据咱学过的 HTML 基础，应该知道，没有标签体的情况下是可以省略闭合标签的，咱这里就不省略了，后续还要往里面加东西。

### 5.6 创建启动类

有了配置文件，下一步可以来读这个配置文件了。在 `a_quickstart_byname` 包下创建一个 `QuickstartByNameApplication` 类，并声明 `main` 方法：

```java
public class QuickstartByNameApplication {
    public static void main(String[] args) {
    
    }
}
```

> （我个人的习惯，在写 `main` 方法时喜欢在方法上顺带抛 `Exception` ，这样大部分场景下可以不用关心 `try-catch` 操作，所以后续看到 `main` 方法中带了 `throws Exception` 的操作，不要方，个人编码习惯而已）

`main` 方法中要读这个配置文件，方法有很多种，咱快速入门中先来使用一种比较简单的方法：

```java
public static void main(String[] args) throws Exception {
    BeanFactory factory = new ClassPathXmlApplicationContext("basic_dl/quickstart-byname.xml");
    Person person = (Person) factory.getBean("person");
    System.out.println(person);
}
```

解释一下这段代码的意思。读取配置文件，需要一个载体来加载它，这里咱选用 `ClassPathXmlApplicationContext` 来加载。加载完成后咱直接使用 `BeanFactory` 接口来接收（多态思想）。下一步就可以从 `BeanFactory` 中获取 `person` 了，由于咱在配置文件中声明了 id ，故这里就可以直接把 id 传入，`BeanFactory` 就可以给我们返回 `Person` 对象。

运行 `main` 方法，可以成功打印出 `Person` 的全限定类名 + 内存地址，证明编写成功。

```css
com.linkedbear.spring.basic_dl.a_quickstart_byname.bean.Person@6a4f787b
```

到这里，就可以轻松上手 SpringFramework 中 IOC 依赖查找的实现了。

## 小结与思考

1. 什么是 SpringFramework ？为什么要用 SpringFramework ？
2. 动手完成一个最基本的 IOC 依赖查找实例。

【上面的依赖查找只是 SpringFramework 最最基本的方式，下一章咱介绍更多关于依赖查找的使用方式，以及了解 IOC 的另一种实现：**依赖注入**】

# 5. 入门-IOC依赖查找&依赖注入

上一章中咱引入了一个最最简单的依赖查找实例，本章咱会继续展开更多的依赖查找实验，来体会 IOC 的依赖查找。后半段咱会介绍 IOC 的另外一个实现方式：依赖注入。

## 1. 依赖查找【掌握】

### 1.1 最简单的实验-byName

上一章已经做过最简单的实验了，不再重复。

### 1.2 根据类型查找-byType

> 本小节源码位置：`com.linkedbear.spring.basic_dl.b_bytype`

为了与上面的实验区分开，咱复制原有的 `quickstart-byname.xml` ，并拷贝出一份新的 `quickstart-bytype.xml` ，咱在这里面修改。

声明 bean 时，这次我不再声明 id 属性：

```xml
<bean class="com.linkedbear.spring.basic_dl.b_bytype.bean.Person"></bean>
```

启动类 `QuickstartByTypeApplication` 中，这次调用的方法不再是传 name 的 `getBean` 方法，而是直接传 `Class` 类型：

```java
public static void main(String[] args) throws Exception {
    BeanFactory factory = new ClassPathXmlApplicationContext("basic_dl/quickstart-bytype.xml");
    Person person = factory.getBean(Person.class);
    System.out.println(person);
}
```

有木有注意到，这次接收的 person 不用强转了！（那不是废话嘛 →_→ ，都把类型传进去了，人家 `BeanFactory` 给你找的时候肯定就是这个类型呀）

运行 `main` 方法，发现可以正常打印出 `Person` 的全限定名：

```css
com.linkedbear.spring.basic_dl.b_bytype.bean.Person@6d4b1c02
```

### 1.3 接口与实现类

咱把之前介绍 IOC 思想的 Dao 拿过来：

![img](./assets/9ffa50d919b843a19dcc4997db1da4e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

之后在 `quickstart-bytype.xml` 中加入 `DemoDaoImpl` 的声明定义：

```xml
<bean class="com.linkedbear.spring.basic_dl.b_bytype.dao.impl.DemoDaoImpl"/>
```

之后在启动类 `QuickstartByTypeApplication` 中，借助 `BeanFactory` 取出 `DemoDao` ，并打印 `findAll` 方法的返回数据：

```java
public static void main(String[] args) throws Exception {
    BeanFactory factory = new ClassPathXmlApplicationContext("basic_dl/quickstart-bytype.xml");
    Person person = factory.getBean(Person.class);
    System.out.println(person);

    DemoDao demoDao = factory.getBean(DemoDao.class);
    System.out.println(demoDao.findAll());
}
```

运行 `main` 方法，控制台可以打印出 `[aaa, bbb, ccc]` ，证明 `DemoDaoImpl` 也成功注入，并且 `BeanFactory` 可以根据接口类型，找到对应的实现类。

## 2. 依赖注入【掌握】

由上面的实例可以发现一个问题：创建的 Bean 都是不带属性的！如果我要创建的 Bean 需要一些预设的属性，那该怎么办呢？那就涉及到 IOC 的另外一种实现了，就是**依赖注入**。还是延续 IOC 的思想，**如果你需要属性依赖，不要自己去找，交给 IOC 容器，让它帮你找**，并给你赋上值。

下面咱快速体验一个依赖注入的例子。

> 本小节源码位置：`com.linkedbear.spring.basic_di.a_quickstart_set`

### 2.1 最简单的实验-简单属性值注入

新建一个包 `basic_di` ，咱在这里面写有关依赖注入的实验。

#### 2.1.1 声明类+配置文件

声明两个类：`Person` 与 `Cat` ，形成“猫需要依赖人”的场景：

```java
public class Person {
    private String name;
    private Integer age;
    // getter and setter ......
}

public class Cat {
    private String name;
    private Person master;
    // getter and setter ......
}
```

之后，咱在 `resources` 目录下新建 `basic_di` 文件夹，并声明配置文件 `inject-set.xml` ：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="person" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Person"></bean>

    <bean id="cat" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Cat"></bean>
</beans>
```

到现在为止，这些操作还都是咱学过的内容吧，没有新的知识。

#### 2.1.2 编写启动类

回到包下，新增一个启动类 `QuickstartInjectBySetXmlApplication` ，并编写 `main` 方法初始化 `BeanFactory` ：

```java
public class QuickstartInjectBySetXmlApplication {
    public static void main(String[] args) throws Exception {
        BeanFactory beanFactory = new ClassPathXmlApplicationContext("basic_di/inject-set.xml");
        Person person = beanFactory.getBean(Person.class);
        System.out.println(person);
        
        Cat cat = beanFactory.getBean(Cat.class);
        System.out.println(cat);
    }
}
```

运行 `main` 方法，发现打印的 person 与 cat 的所有属性都是 null ：

```ini
Person{name='null', age=null}
Cat{name='null', master=null}
```

#### 2.1.3 给Person赋属性值

下面咱给 Person 的两个属性赋值。在 `<bean>` 标签中，可以声明如下一些标签：

![img](./assets/0b87bc08c234447ea7dab43d246ad0bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这些标签咱不用全记住，学到哪个记哪个即可。现在咱要用的是第一个：**`property`** 。

在 person 的 `<bean>` 标签中声明 `property` 标签，这里面有两个属性：**name - 属性名，value - 属性值**。所以咱可以用如下方式来进行属性赋值：

```xml
<bean id="person" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Person">
    <property name="name" value="test-person-byset"/>
    <property name="age" value="18"/>
</bean>
```

声明之后，保存，回到启动类，重新运行，发现 person 已经有值了：

```ini
Person{name='test-person-byset', age=18}
Cat{name='null', master=null}
```

### 2.2 关联Bean赋值

上面打印的结果明显 cat 还没有值，而且 master 的类型是 `Person` ，下面咱要给 cat 赋值。

对于 `property` 标签，除了可以声明 `value` 之外，还可以声明另外一个属性：**`ref`** ，它代表**要关联赋值的 Bean 的 id** 。 由此，对于 cat 中的 master 属性，可以有如下赋值方法：

```xml
<bean id="cat" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Cat">
    <property name="name" value="test-cat"/>
    <!-- ref引用上面的person对象 -->
    <property name="master" ref="person"/>
</bean>
```

声明好后，重新运行启动类，发现 cat 也有属性了：

```ini
Person{name='test-person-byset', age=18}
Cat{name='test-cat', master=Person{name='test-person-byset', age=18}}
```

------

最后，咱对比一下这两种 IOC 的实现方式。

## 3. 【面试题】依赖查找与依赖注入的对比

以下答案仅供参考，可根据自己的理解调整回答内容：

- 作用目标不同
  - 依赖注入的作用目标通常是类成员
  - 依赖查找的作用目标可以是方法体内，也可以是方法体外
- 实现方式不同
  - 依赖注入通常借助一个上下文被动的接收
  - 依赖查找通常主动使用上下文搜索

## 小结与练习

1. IOC 的两种实现方式是什么？它们的区别和联系是什么？
2. 动手实现三层架构中的 service 层与 dao 层，实际体会依赖查找与依赖注入的使用。

【快速入门之后，下面咱就可以慢慢解锁新的姿势了，下一章咱来介绍更多关于依赖查找的方式，以及引出 SpringFramework 中的另一个核心概念：**`ApplicationContext`** 】

# 6. IOC基础-依赖查找高级&BeanFactory与ApplicationContext

上一章，咱了解了 IOC 的两种实现的基本用法，这一章咱来介绍更多关于依赖查找的使用方式。

> 本章源码均在：`com.linkedbear.spring.basic_dl`

## 1. 依赖查找的多种姿势【掌握】

### 1.1 ofType

试想，如果一个接口有多个实现，而咱又想一次性把这些都拿出来，那 `getBean` 方法显然就不够用了，需要使用额外的方式。

回到 `basic_dl` 包下，咱新创建一个 `oftype` 的包，来测试 **ofType** 的查找方式。

#### 1.1.1 声明Bean+配置文件

声明一个 `DemoDao` ，并声明 3 种对应的实现类，分别模拟操作 MySQL 、Oracle 、Postgres 数据库的实现类：

![img](./assets/d521e012f54941acb5daf7a54d756a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

对应的配置类，也把这几个 Bean 都注册上：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="demoMySQLDao" class="com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoMySQLDao"/>
    <bean id="demoOracleDao" class="com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoOracleDao"/>
    <bean id="demoPostgreDao" class="com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoPostgresDao"/>
</beans>
```

#### 1.1.2 测试启动类

在启动类中，创建 `BeanFactory` 后，尝试一次性取出多个 Bean ，结果发现 `BeanFactory` 中并没有这样的方法：

![img](./assets/0a59f26ff7a948ccad9c7ce57965d3a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

此时咱的内心一定是：

![img](./assets/4bd697043b234c0a863a7119f17a51ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

没有这种实现吗？？？那我咋获取这些呢？

其实并不是人家没实现，只是咱用错了接口而已 (￣▽￣)／

这样，咱先改，改完了再解释为什么这么改。

#### 1.1.3 改用ApplicationContext

将 `BeanFactory` 接口换为 `ApplicationContext` ，再次尝试调用方法，发现了一个这样的方法：

![img](./assets/e52eadc4868f4085955d1d3cdef02b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

它可以**传入一个类型，返回一个 Map** ，而 Map 中的 value 不难猜测就是**传入的参数类型对应的那些类 / 实现类**。

那咱就拿出来，foreach 一下呗：

```java
public class OfTypeApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("basic_dl/quickstart-oftype.xml");
        Map<String, DemoDao> beans = ctx.getBeansOfType(DemoDao.class);
        beans.forEach((beanName, bean) -> {
            System.out.println(beanName + " : " + bean.toString());
        });
    }
}
```

运行 `main` 方法，控制台真的打印了上面声明的那3个类：

```kotlin
demoMySQLDao : com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoMySQLDao@4883b407
demoOracleDao : com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoOracleDao@7d9d1a19
demoPostgreDao : com.linkedbear.spring.basic_dl.c_oftype.dao.impl.DemoPostgresDao@39c0f4a
```

这样就实现了传入一个接口 / 抽象类，返回容器中所有的实现类 / 子类。

讲到这里，咱先停下来，解释下为什么换用 `ApplicationContext` 。

## 2. BeanFactory与ApplicationContext【掌握】

借助 IDEA ，发现 `ApplicationContext` 也是一个接口，而且通过接口继承关系发现它是 `BeanFactory` 的子接口。那咱想了解这两个接口，最好的办法还是先翻一翻官方文档，从官方文档中尝试获取最权威的解释。

### 2.1 官方文档的解释

在官方文档 [docs.spring.io/spring/docs…](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring%2Fdocs%2F5.2.x%2Fspring-framework-reference%2Fcore.html%23beans-introduction) 中，有一个段落解释了这两个接口的关系：

> The `org.springframework.beans` and `org.springframework.context` packages are the basis for Spring Framework’s IoC container. The [`BeanFactory`](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F5.2.x%2Fjavadoc-api%2Forg%2Fspringframework%2Fbeans%2Ffactory%2FBeanFactory.html) interface provides an advanced configuration mechanism capable of managing any type of object. [`ApplicationContext`](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F5.2.x%2Fjavadoc-api%2Forg%2Fspringframework%2Fcontext%2FApplicationContext.html) is a sub-interface of `BeanFactory`. It adds:
>
> - Easier integration with Spring’s AOP features
> - Message resource handling (for use in internationalization)
> - Event publication
> - Application-layer specific contexts such as the `WebApplicationContext` for use in web applications.
>
> `org.springframework.beans` 和 `org.springframework.context` 包是 SpringFramework 的 IOC 容器的基础。`BeanFactory` 接口提供了一种高级配置机制，能够管理任何类型的对象。`ApplicationContext` 是 `BeanFactory` 的子接口。它增加了：
>
> - 与 SpringFramework 的 AOP 功能轻松集成
> - 消息资源处理（用于国际化）
> - 事件发布
> - 应用层特定的上下文，例如 Web 应用程序中使用的 `WebApplicationContext`

这样说下来，给咱的主观感受是：**`ApplicationContext` 包含 `BeanFactory` 的所有功能，并且人家还扩展了好多特性**，其实就是这么回事。

而且，官方文档的下面还有一段，解释了我们为什么应该用 `ApplicationContext` 而不是 `BeanFactory` ：[docs.spring.io/spring/docs…](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring%2Fdocs%2F5.2.x%2Fspring-framework-reference%2Fcore.html%23context-introduction-ctx-vs-beanfactory)

> You should use an `ApplicationContext` unless you have a good reason for not doing so, with `GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext` as the common implementations for custom bootstrapping. These are the  primary entry points to Spring’s core container for all common purposes: loading of configuration files, triggering a classpath scan,  programmatically registering bean definitions and annotated classes, and (as of 5.0) registering functional bean definitions.
>
> 你应该使用 `ApplicationContext` ，除非能有充分的理由解释不需要的原因。一般情况下，我们推荐将 `GenericApplicationContext` 及其子类 `AnnotationConfigApplicationContext` 作为自定义引导的常见实现。这些实现类是用于所有常见目的的 SpringFramework 核心容器的主要入口点：加载配置文件，触发类路径扫描，编程式注册 Bean 定义和带注解的类，以及（从5.0版本开始）注册功能性 Bean 的定义。

这段话的下面还给了一张表，对比了 `BeanFactory` 与 `ApplicationContext` 的不同指标：

| Feature                                                      | `BeanFactory` | `ApplicationContext` |
| ------------------------------------------------------------ | ------------- | -------------------- |
| Bean instantiation/wiring —— Bean的实例化和属性注入          | Yes           | Yes                  |
| Integrated lifecycle management —— 生命周期管理              | No            | Yes                  |
| Automatic `BeanPostProcessor` registration —— Bean后置处理器的支持 | No            | Yes                  |
| Automatic `BeanFactoryPostProcessor` registration —— BeanFactory后置处理器的支持 | No            | Yes                  |
| Convenient `MessageSource` access (for internalization) —— 消息转换服务（国际化） | No            | Yes                  |
| Built-in `ApplicationEvent` publication mechanism —— 事件发布机制（事件驱动） | No            | Yes                  |

由此可以发现，`ApplicationContext` 真的比 `BeanFactory` 强大太多了，所以咱还是选择使用 `ApplicationContext` 吧！

### 2.2 【面试题】BeanFactory与ApplicationContext的对比

既然都聊到这个份上了，那咱就顺便来一道面试题吧，看看这个问题如何在面试中回答会比较合适。

以下答案仅供参考，可根据自己的理解调整回答内容：

`BeanFactory` 接口提供了一个**抽象的配置和对象的管理机制**，`ApplicationContext` 是 `BeanFactory` 的子接口，它简化了与 AOP 的整合、消息机制、事件机制，以及对 Web 环境的扩展（ `WebApplicationContext` 等），`BeanFactory` 是没有这些扩展的。

`ApplicationContext` 主要扩展了以下功能：

- AOP 的支持（ `AnnotationAwareAspectJAutoProxyCreator` 作用于 Bean 的初始化之后 ）
- 配置元信息（ `BeanDefinition` 、`Environment` 、注解等 ）
- 资源管理（ `Resource` 抽象 ）
- 事件驱动机制（ `ApplicationEvent` 、`ApplicationListener` ）
- 消息与国际化（ `LocaleResolver` ）
- `Environment` 抽象（ SpringFramework 3.1 以后）

> 目前可以只记住前面的部分，括号内的内容可以先略过，等到学完整遍的 SpringFramework ，再回过头看时自然会有那种“会心一笑”的感觉的ヽ(￣▽￣)ﾉ 。

------

好了，初步了解了 `BeanFactory` 与 `ApplicationContext` 的区别，也知道 `ApplicationContext` 更加强大，下面咱就继续研究依赖查找的花板子吧。

## 3. 继续研究依赖查找

### 3.1 withAnnotation【熟悉】

IOC 容器除了可以根据一个父类 / 接口来找实现类，还可以根据类上标注的注解来查找对应的 Bean 。下面咱来测试包含注解的 Bean 如何被查找。

#### 3.1.1 声明Bean+注解+配置文件

新建一个包 `d_withanno` ，并在里面声明一个注解：`@Color` 。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Color {

}
```

之后，创建几个类，以及运行 `main` 方法的启动类：

![img](./assets/89e8d70873874dd783527e82554a4589~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

其中，`Black` 与 `Red` 的类上标注 `@Color` 注解，`Dog` 不标注（废话，一只狗上什么色儿~~~）

对应的，配置文件中声明好这几个类。

#### 3.1.2 测试启动类

`ApplicationContext` 中有一个方法叫 `getBeansWithAnnotation` ，它可以传入一个注解的 class ，返回所有被这个注解标注的 bean 。于是咱的测试启动类可以这样写：

```java
public class WithAnnoApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("basic_dl/quickstart-withanno.xml");
        Map<String, Object> beans = ctx.getBeansWithAnnotation(Color.class);
        beans.forEach((beanName, bean) -> {
            System.out.println(beanName + " : " + bean.toString());
        });
    }
}
```

运行 `main` 方法，可以发现控制台只打印了 `Black` 和 `Red` ，证明成功取出。

```kotlin
black : com.linkedbear.spring.basic_dl.d_withanno.bean.Black@553f17c
red : com.linkedbear.spring.basic_dl.d_withanno.bean.Red@6c3708b3
```

### 3.2 获取IOC容器中的所有Bean【熟悉】

如果真的会有这么一个需求，要取出当前 IOC 容器中的所有 bean ，这个时候一个一个取是不现实的，因为你根本不知道都有谁，不知道到底有哪些你还没见过的小盆友们。。。所以这个时候就要用到 `ApplicationContext` 的另一个方法了：`getBeanDefinitionNames` 。

看这个方法名，感觉像是获取 bean 的定义名称，这跟 name 有什么关系吗？这里先告诉你，它获取的就是那些 Bean 的 **id** ，至于这些关于定义的信息，后续也会讲到的，小伙伴们先学习这些比较基础的东西即可。

接下来咱就试一下这个 `getBeanDefinitionNames` 方法的效果，编写一个新的启动类，这次咱就不再造 bean 了，咱直接拿上面刚测试过的吧：

```java
public class BeannamesApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("basic_dl/quickstart-withanno.xml");
        String[] beanNames = ctx.getBeanDefinitionNames();
        // 利用jdk8的Stream快速编写打印方法
        Stream.of(beanNames).forEach(System.out::println);
    }
}
```

运行 `main` 方法，发现控制台上真的打印了咱自己创建的几个 bean ：

```
black
red
dog
```

那既然 Bean 的 id 都出来了，那取出来还不是轻而易举？这个咱都很熟悉了，就不再演示了。

## 4. 依赖查找的高级使用——延迟查找【熟悉】

对于一些特殊的场景，需要依赖容器中的某些特定的 Bean ，但当它们不存在时也能使用默认 / 缺省策略来处理逻辑。这个时候，使用上面已经学过的方式倒是可以实现，但编码可能会不很优雅。

### 4.1 使用现有方案实现Bean缺失时的缺省加载

咱把设计做的简单一些，准备两个 bean ：`Cat` 和 `Dog` ，但是在 xml 中咱只注册 `Cat` ，这样 IOC 容器中就只有 `Cat` ，没有 `Dog` 。

之后，咱来编写启动类。由于 Dog 没有在 IOC 容器中，所以调用 `getBean` 方法时会报 `NoSuchBeanDefinitionException` ，为了保证能在没有找到 Bean 的时候启用缺省策略，咱可以在 catch 块中手动创建，实现代码如下：

```java
public class ImmediatlyLookupApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("basic_dl/quickstart-lazylookup.xml");
        Cat cat = ctx.getBean(Cat.class);
        System.out.println(cat);
        
        Dog dog;
        try {
            dog = ctx.getBean(Dog.class);
        } catch (NoSuchBeanDefinitionException e) {
            // 找不到Dog时手动创建
        	dog = new Dog();
        }
        System.out.println(dog);
    }

}
```

可以发现这种编码方式相当不优雅，而且很别扭（性能也低）。如果真的后续每一个 bean 都这样操作，那编码量岂不是巨大？这肯定不行，一定有改良方案。

### 4.2 改良-获取之前先检查

既然作为一个容器，能获取自然就能有检查，`ApplicationContext` 中有一个方法就可以专门用来检查容器中是否有指定的 Bean ：`containsBean`

```java
    Dog dog = ctx.containsBean("dog") ? (Dog) ctx.getBean("dog") : new Dog();
```

但注意，这个 `containsBean` 方法只能传 bean 的 id ，不能查类型，所以虽然可以改良前面的方案，但还是有问题：如果 Bean 的名不叫 dog ，叫 wangwang ，那这个方法岂不是废了？所以这个方案还是不够好，需要改良。

### 4.3 改良-延迟查找

如果能有一种机制，我想获取一个 Bean 的时候，你可以**先不给我报错，先给我一个包装让我拿着，回头我自己用的时候再拆开决定里面有还是没有**，这样是不是就省去了 IOC 容器报错的麻烦事了呢？在 SpringFramework 4.3 中引入了一个新的 API ：**`ObjectProvider`** ，它可以实现延迟查找。

于是，咱可以改良上面的代码如下：（为了保留上面的案例示范，下面新起一个类）

```java
public class LazyLookupApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("basic_dl/quickstart-lazylookup.xml");
        Cat cat = ctx.getBean(Cat.class);
        System.out.println(cat);
        // 下面的代码会报Bean没有定义 NoSuchBeanDefinitionException
        // Dog dog = ctx.getBean(Dog.class);
    
        // 这一行代码不会报错
        ObjectProvider<Dog> dogProvider = ctx.getBeanProvider(Dog.class);
    }
}
```

可以发现，`ApplicationContext` 中有一个方法叫 `getBeanProvider` ，它就是返回上面说的那个**“包装”**。如果直接 `getBean` ，那如果容器中没有对应的 Bean ，就会报 `NoSuchBeanDefinitionException`；如果使用这种方式，运行 `main` 方法后发现并没有报错，只有调用 `dogProvider` 的 `getObject` ，真正要取包装里面的 Bean 时，才会报异常。所以总结下来，`ObjectProvider` 相当于**延后了 Bean 的获取时机，也延后了异常可能出现的时机**。

但是，上面的问题还没有被解决呀，调用 `getObject` 方法还是会报异常，那下面咱就继续研究 `ObjectProvider` 的其他一些方法。

### 4.4 延迟查找-方案实现

`ObjectProvider` 中还有一个方法：`getIfAvailable` ，它可以在**找不到 Bean 时返回 null 而不抛出异常**。使用这个方法，就可以避免上面的问题了。改良之后的代码如下：

```java
    Dog dog = dogProvider.getIfAvailable();
    if (dog == null) {
        dog = new Dog();
    }
```

### 4.5 ObjectProvider在jdk8的升级

随着 SpringFramework 5.0 基于 jdk8 的发布，函数式编程也被大量用于 SpringFramework 中。`ObjectProvider` 中新加了几个方法，可以使编码更佳优雅。

看着上面 4.4 节的那几行代码，有木有联想到 `Map` 中的 `getOrDefault` ？由此，`ObjectProvider` 在 SpringFramework 5.0 后扩展了一个带 `Supplier` 参数的 `getIfAvailable` ，它可以在找不到 Bean 时直接用 **`Supplier`** 接口的方法返回默认实现，由此上面的代码还可以进一步简化为：

```java
    Dog dog = dogProvider.getIfAvailable(() -> new Dog());
```

或者更简单的，使用方法引用：

```java
    Dog dog = dogProvider.getIfAvailable(Dog::new);
```

当然，一般情况下，取出的 Bean 都会马上或者间歇的用到，`ObjectProvider` 还提供了一个 `ifAvailable` 方法，可以在 Bean 存在时执行 `Consumer` 接口的方法：

```java
    dogProvider.ifAvailable(dog -> System.out.println(dog)); // 或者使用方法引用
```

以上就是关于延迟查找的内容，这种方案可以使用，但在日常开发中可能使用的不是很多，小伙伴们实际动手操作一遍，有一个印象即可。后续如果升级到更高的位置，这部分或许会在封装组件和底层时用到。

## 小结与练习

1. 如何对比 `BeanFactory` 与 `ApplicationContext` ？`ApplicationContext` 都在 `BeanFactory` 的基础上扩展了哪些特性？
2. 动手练习一下前面几章已经学过的所有 `ApplicationContext` 中的依赖查找方式，加深印象。

【对于依赖查找这部分，其实难度还不算很大，小伙伴只需要多加练习，掌握起来也是非常简单的。下一章咱先不深入研究依赖注入，来聊一个区别于 xml 的驱动方式：**注解驱动**】

# 7. IOC基础-注解驱动IOC与组件扫描

自打 SpringFramework 推出 3.0 后，最低的版本支持来到了 Java 5 ，我们也知道，Java 5 的最大新特性之一就是引入了**注解**。SpringFramework 3.0 开始也引入了大量注解，代替 xml 的方式进行声明式开发。这一章，咱来了解 SpringFramework 中的注解驱动开发，同时体会几个案例。

## 1. 注解驱动IOC容器【掌握】

在 xml 驱动的 IOC 容器中，咱使用的是 `ClassPathXmlApplicationContext` ，它对应的是类路径下的 xml 驱动。对于注解配置的驱动，那自然可以试着猜一下，应该是 Annotation 开头的，ApplicationContext 结尾。那就是下面咱介绍的 `AnnotationConfigApplicationContext` 。

咱新建一个 `annotation` 包，用来讲解关于注解驱动 IOC 的部分。

> 本章源码均在 `com.linkedbear.spring.annotation`

### 1.1 注解驱动IOC的依赖查找

#### 1.1.1 配置类的编写与Bean的注册

对比于 xml 文件作为驱动，注解驱动需要的是**配置类**。一个配置类就可以类似的理解为一个 xml 。配置类没有特殊的限制，只需要在类上标注一个 `@Configuration` 注解即可。

```java
@Configuration
public class QuickstartConfiguration {

}
```

在 xml 中，咱声明 Bean 是通过 `<bean>` 标签。

```xml
<bean id="person" class="com.linkedbear.spring.basic_dl.a_quickstart_byname.bean.Person"/>
```

在配置类中，要想替换掉 `<bean>` 标签，自然也能想到，它是使用 `@Bean` 注解。

```java
@Bean
public Person person() {
    return new Person();
}
```

这种使用方式，可以解释为：**向 IOC 容器注册一个类型为 Person ，id 为 person 的 Bean** 。**方法的返回值代表注册的类型，方法名代表 Bean 的 id** 。当然，也可以直接在 `@Bean` 注解上显式的声明 Bean 的 id ，只不过在注解驱动的范畴里，它不叫 id 而是叫 **name** ：

```java
@Bean(name = "aaa") // 4.3.3之后可以直接写value
public Person person() {
    return new Person();
}
```

这样就算把配置类编写好了。

#### 1.1.2 启动类初始化注解IOC容器

像上面所说的，咱使用 `AnnotationConfigApplicationContext` 来驱动注解 IOC 容器，在构造方法中把配置类传入：

```java
public class AnnotationConfigApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(QuickstartConfiguration.class);
        Person person = ctx.getBean(Person.class);
        System.out.println(person);
    }
}
```

运行，可以发现 `Person` 被打印，证明编写成功。

### 1.2 注解驱动IOC的依赖注入

编码方式的依赖注入可以说是相当简单了，直接在创建对象后先别着急返回，把里面的值都 set 进去，再返回即可：

```java
@Bean
public Person person() {
    Person person = new Person();
    person.setName("person");
    person.setAge(123);
    return person;
}
```

就相当于：

```xml
<bean id="person" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Person">
    <property name="name" value="test-person-byset"/>
    <property name="age" value="18"/>
</bean>
```

------

```java
@Bean
public Cat cat() {
    Cat cat = new Cat();
    cat.setName("test-cat-anno");
    // 直接拿上面的person()方法作为返回值即可，相当于ref
    cat.setMaster(person());
    return cat;
}
```

就相当于：

```xml
<bean id="cat" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Cat">
    <property name="name" value="test-cat"/>
    <property name="master" ref="person"/>
</bean>
```

其余部分与上面一模一样，不再展开。

### 1.3 注解IOC容器的其他用法

翻看 `AnnotationConfigApplicationContext` 的构造方法，可以发现它还有一个方法，是传入一组 `basePackage` ，翻译过来是 “根包” 的意思，它又是什么意思呢？这就涉及到下面的概念了：**组件注册与扫描**。

## 2. 组件注册与组件扫描【掌握】

上面声明的方式，如果需要注册的组件特别多，那编写这些 `@Bean` 无疑是超多工作量，于是 SpringFramework 中给咱整了几个注解出来，可以帮咱快速注册需要的组件，这些注解被成为**模式注解 ( stereotype annotation )**。

### 2.1 一切组件注册的根源：@Component

在类上标注 `@Component` 注解，即代表该类会被注册到 IOC 容器中作为一个 Bean 。

```java
@Component
public class Person {
    
}
```

相当于 xml 中的：

```xml
<bean class="com.linkedbear.spring.basic_dl.a_quickstart_byname.bean.Person"/>
```

如果想指定 Bean 的名称，可以直接在 `@Component` 中声明 **value** 属性即可：

```java
@Component("aaa")
public class Person { }
```

如果不指定 Bean 的名称，它的默认规则是 **“类名的首字母小写”**（例如 `Person` 的默认名称是 `person` ，`DepartmentServiceImpl` 的默认名称是 `departmentServiceImpl` ）。

### 2.2 组件扫描

只声明了组件，咱在写配置类时如果还是只写 `@Configuration` 注解，随后启动 IOC 容器，那它是感知不到有 `@Component` 存在的，一定会报 `NoSuchBeanDefinitionException` 。

为了解决这个问题，咱需要引入一个新的注解：`@ComponentScan` 。

#### 2.2.1 @ComponentScan

在配置类上额外标注一个 `@ComponentScan` ，并指定要扫描的路径，它就可以**扫描指定路径包及子包下的所有 `@Component` 组件**：

```java
@Configuration
@ComponentScan("com.linkedbear.spring.annotation.c_scan.bean")
public class ComponentScanConfiguration {
    
}
```

如果不指定扫描路径，则**默认扫描本类所在包及子包下的所有 `@Component` 组件**。

注意一点，如果 SpringFramework 的版本比较老，可能会看到这样的写法：

```java
@ComponentScan(basePackages = "com.linkedbear.spring.annotation.c_scan.bean")
```

这两个属性实质上是一样的，写哪个都可以。

另外注意 `basePackages` 是复数，它可以声明多个扫描包。

声明上 `@ComponentScan` 之后，重新启动配置类，可以发现 `Person` 已经成功被注册。

#### 2.2.2 不使用@ComponentScan的组件扫描

其实，如果不写 `@ComponentScan` ，也是可以做到组件扫描的。在 `AnnotationConfigApplicationContext` 的构造方法中有一个类型为 String 可变参数的构造方法：

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext("com.linkedbear.spring.annotation.c_scan.bean");
```

这样声明好要扫描的包，也是可以直接扫描到那些标注了 `@Component` 的 Bean 的。

#### 2.2.3 xml中启用组件扫描

组件扫描可不是注解驱动 IOC 的专利，对于 xml 驱动的 IOC 同样可以启用组件扫描，它只需要在 xml 中声明一个标签即可：

```xml
<context:component-scan base-package="com.linkedbear.spring.annotation.c_scan.bean"/>
<!-- 注意标签是package，不是packages，代表一个标签只能声明一个根包 -->
```

之后使用 `ClassPathXmlApplicationContext` 驱动，也是可以获取到 `Person` 的。

### 2.3 组件注册的其他注解

SpringFramework 为了迎合咱在进行 Web 开发时的三层架构，它额外提供了三个注解：`@Controller` 、`@Service` 、`@Repository` ，分别代表表现层、业务层、持久层。这三个注解的作用与 `@Component` 完全一致，其实它们的底层也就是 `@Component` ：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller { ... }
```

有了这几个注解，那么在进行符合三层架构的开发时，对于那些 ServiceImpl ，就可以直接标注 `@Service` 注解，而不用一个一个的写 `<bean>` 标签或者 `@Bean` 注解了。

> 多提一嘴，其实 `@Repository` 是 SpringFramework 2.0 就已经有了的，只是到了 SpringFramework 3.0 才开始全面支持注解驱动开发。

### 2.4 @Configuration也是@Component

如果上面指定的扫描包中，去掉后面的 bean ，让它扫描整个根包，咱修改一下启动类：

```java
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(ComponentScanConfiguration.class);
        //或者直接扫描com.linkedbear.spring.annotation.c_scan包
        String[] beanNames = ctx.getBeanDefinitionNames();
        Stream.of(beanNames).forEach(System.out::println);
    }
```

运行 `main` 方法，会发现配置类 `ComponentScanConfiguration` 也被注册到 IOC 容器了：（上面的一大堆东西咱不关心，只看最后 3 行）

```kotlin
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
componentScanConfiguration
cat
person
```

可能会有小伙伴疑惑了，配置类不应该像配置文件那样，它只是做一个配置而已吗？咱看一眼 `@Configuration` 注解：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration { ... }
```

好吧，它也标注了 `@Component` 注解，证明确实它也会被视为 bean ，注册到 IOC 容器。

## 3. 注解驱动与xml驱动互通【掌握】

如果一个应用中，既有注解配置，又有 xml 配置，这个时候就需要由一方引入另一方了。两种方式咱都介绍一下。

### 3.1 xml引入注解

在 xml 中要引入注解配置，需要开启注解配置，同时注册对应的配置类：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd 
        http://www.springframework.org/schema/context 
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 开启注解配置 -->
    <context:annotation-config />
    <bean class="com.linkedbear.spring.annotation.d_importxml.config.AnnotationConfigConfiguration"/>
</beans>
```

### 3.2 注解引入xml

在注解配置中引入 xml ，需要在配置类上标注 `@ImportResource` 注解，并声明配置文件的路径：

```java
@Configuration
@ImportResource("classpath:annotation/beans.xml")
public class ImportXmlAnnotationConfiguration {
    
}
```

具体的组件注册，可自由发挥，小册不再展开演示。

## 小结与练习

1. 注解驱动的 IOC 容器与 xml 驱动的 IOC 容器有什么不同？
2. 动手练习上面提到的几个演示案例，并尝试混用两种 IOC 容器的实现，加深对 IOC 容器的认识。

【了解了注解驱动 IOC 之后，下面咱要对依赖注入进行比较深入的研究了，这部分内容比较多，咱拆成 3 章讲解】

# 8. IOC基础-依赖注入-属性注入&SpEL表达式

由于依赖注入的内容比较多，咱把依赖注入拆分成 3 章来学习。

依赖注入的部分，咱会分述 xml 方式与注解方式两种情况来学习，力求让小伙伴都完全掌握。

## 1. setter属性注入【掌握】

论依赖注入哪个最简单，那当属 “ setter 注入” 。下面咱来介绍最简单的 Bean 的 setter 注入。

> 本小节源码位置：`com.linkedbear.spring.basic_di.a_quickstart_set`

### 1.1 xml方式的setter注入

在最开始的入门阶段，其实咱就已经学过基于 xml 的 setter 注入了，简单回顾一下吧：

```xml
<bean id="person" class="com.linkedbear.spring.basic_di.a_quickstart_set.bean.Person">
    <property name="name" value="test-person-byset"/>
    <property name="age" value="18"/>
</bean>
```

### 1.2 注解方式的setter注入

注解形式的 setter 注入，咱之前学过的是在 bean 的创建时，编程式设置属性：

```java
@Bean
public Person person() {
    Person person = new Person();
    person.setName("test-person-anno-byset");
    person.setAge(18);
    return person;
}
```

## 2. 构造器注入【掌握】

有一些 bean 的属性依赖，需要在调用构造器（构造方法）时就设置好；或者另一种情况，有一些 bean 本身没有无参构造器，这个时候就必须使用**构造器注入**了。

> 本小节源码位置：`com.linkedbear.spring.basic_di.b_constructor`

### 2.1 修改Bean

为了演示构造器注入，需要给 `Person` 添加一个全参数构造方法：

```java
public Person(String name, Integer age) {
    this.name = name;
    this.age = age;
}
```

加上这个构造方法后，默认的无参构造方法就没了，这样原来的 `<bean>` 标签创建时就会失效，提示没有默认的构造方法：

```csharp
Caused by: java.lang.NoSuchMethodException: com.linkedbear.spring.basic_di.b_constructor.bean.Person.<init>()
```

为此，咱需要学习新的 bean 构造和属性注入方法。

### 2.2 xml方式的构造器注入

在 `<bean>` 标签的内部，可以声明一个子标签：`constructor-arg` ，顾名思义，它是指构造器参数，由它可以指定构造器中的属性，来进行属性注入。`constructor-arg` 标签的编写规则如下：

```xml
<bean id="person" class="com.linkedbear.spring.basic_di.b_constructor.bean.Person">
    <constructor-arg index="0" value="test-person-byconstructor"/>
    <constructor-arg index="1" value="18"/>
</bean>
```

一个标签中有两部分，分别指定构造器的参数索引和参数值。这个地方真的能体现出 IDEA 的强大，如果没有在 `<bean>` 标签中声明 `constructor-arg` ，它会直接报红并提示帮你生成：

![img](./assets/b92592e4241f480688f7ac7ab07da281~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

由此，可以对这些属性进行注入。

### 2.3 注解式构造器属性注入

注解驱动的 bean 注册中，也是直接使用编程式赋值即可：

```java
@Bean
public Person person() {
    return new Person("test-person-anno-byconstructor", 18);
}
```

## 3. 注解式属性注入【掌握】

看到这里，是不是突然有点迷？哎，上面不是都介绍了注解式的 setter 和构造器的注入了吗？为什么又突然开了一节介绍呢？

回想一下，注册 bean 的方式不仅有 `@Bean` 的方式，还有组件扫描呢！那些声明式注册好的组件，它们的属性怎么处理呢？所以这一节咱就专门拿出来介绍这部分，如果这部分出现了一些新的内容，咱也同样在 xml 的方式下演示。

> 本小节源码位置：`com.linkedbear.spring.basic_di.c_value_spel`

### 3.1 @Component下的属性注入

咱这次不拿动物举例子了（才疏学浅啦 ~ 搞不了那么多动物的啦），换点颜色玩玩（给你们点颜色康康）。先介绍最简单的属性注入方式：**`@Value`** 。

新建一个 `Black` 类，并声明 `name` 和 `order` ，不过这次咱不设置 setter 方法了：

```java
public class Black {
    private String name;
    private Integer order;
    
    @Override
    public String toString() {
        return "Black{" + "name='" + name + '\'' + ", order=" + order + '}';
    }
}
```

实现注解式属性注入，可以直接在要注入的字段上标注 **`@Value`** 注解：

```java
    @Value("black-value-anno")
    private String name;
    
    @Value("0")
    private Integer order;
```

随后，咱使用组件扫描的形式，将这个 `Black` 类扫描到 IOC 容器，并取出打印：

```java
public class InjectValueAnnoApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext("com.linkedbear.spring.basic_di.c_value_spel.bean");
        Black black = ctx.getBean(Black.class);
        System.out.println("simple value : " + black);
    }
}
```

运行 `main` 方法，发现 `Black` 的属性已经注入进去了：

```ini
simple value : Black{name='black-value-anno', order=0}
```

### 3.2 外部配置文件引入-@PropertySource

不是讲属性注入吗？怎么又扯到外部配置文件了？回想一下咱一开始学 IOC 思想的时候，咱不是搞了一个 properties  文件嘛，如果咱需要在 SpringFramework 中使用的话，应该怎么办呢？还是像之前那样用 Properties 类去 IO  读取？SpringFramework 自然能想到这个需求，于是就又扩展出了一个注解，用于导入外部的配置文件：`@PropertySource` 。

#### 3.2.1 创建Bean+配置文件

新建一个 `Red` 类，结构与 `Black` 完全一致。

之后在工程的 resources 目录下新建一个 `red.properties` ，用于存放 `Red` 的属性的配置：

```properties
red.name=red-value-byproperties
red.order=1
```

#### 3.2.2 引入配置文件

使用时，只需要将 **`@PropertySource`** 注解标注在配置类上，并声明 properties 文件的位置，即可导入外部的配置文件：

```java
@Configuration
// 顺便加上包扫描
@ComponentScan("com.linkedbear.spring.basic_di.c_value_spel.bean")
@PropertySource("classpath:basic_di/value/red.properties")
public class InjectValueConfiguration {
    
}
```

#### 3.2.3 Red类的属性注入

对于 properties 类型的属性，`@Value` 需要配合**占位符**来表示注入的属性，我先写，写完你一下子就明白了：

```java
    @Value("${red.name}")
    private String name;
    
    @Value("${red.order}")
    private Integer order;
```

是不是突然熟悉！这不跟 jsp 里的 el 表达式一个样吗？哎没错，还真就这样！

#### 3.2.4 测试启动类

修改启动类，将包扫描启动改为配置类启动，随后将 `Red` 取出：

```java
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(InjectValueConfiguration.class);
        Red red = ctx.getBean(Red.class);
        System.out.println("properties value : " + red);
    }
```

运行 `main` 方法，控制台打印 `Red` 的信息，证明配置文件的属性已经成功注入：

```ini
properties value : Red{name='red-value-byproperties', order=1}
```

#### 3.2.5 xml中使用占位符

对于 xml 中，占位符的使用方式与 `@Value` 是一模一样的：

```xml
<bean class="com.linkedbear.spring.basic_di.c_value_spel.bean.Red">
    <property name="name" value="${red.name}"/>
    <property name="order" value="${red.order}"/>
</bean>
```

#### 3.2.6 占位符的取值范围【理解】

作为一个 **properties 文件**，它加载到 SpringFramework 的 IOC 容器后，**会转换成 Map 的形式来保存**这些配置，而 SpringFramework 中本身在初始化时就有一些配置项，这些配置项也都放在这个 Map 中。**占位符的取值就是从这些配置项中取**。

> 多提一嘴，实际上这些配置属性和值存放的真实位置是一个叫 **`Environment`** 的抽象中，在后面的 IOC 进阶和高级部分，小册会拿出专门开篇幅讲解 `Environment` 的设计，以及 properties 文件的加载。

### 3.3 SpEL表达式【了解会用】

不是在讲属性注入吗？怎么突然提到 SpEL 了？试想一下，如果咱要在属性注入时，使用一些特殊的数值（如一个 Bean 需要依赖另一个 Bean 的某个属性，或者需要动态处理一个特定的属性值），这种情况 **${}** 的占位符方式就办不了了（占位符只能取配置项），需要一种更强大的表达方式来满足这种需求，这种表达方式就是 SpEL 表达式。

#### 3.3.1 快速了解SpEL

SpEL 全称 Spring Expression Language ，它从 SpringFramework 3.0  开始被支持，它本身可以算 SpringFramework  的组成部分，但又可以被独立使用。它可以支持调用属性值、属性参数以及方法调用、数组存储、逻辑计算等功能。

> 如果有接触过 Struts2 / FreeMarker 的小伙伴应该知道 OGNL ，它也是一种表达式语言，只不过 OGNL  是一个单独的开源项目，而 SpEL 是由 Spring 推出的表达式语言，而且 SpEL 默认本身内嵌在 SpringFramework 中。

#### 3.3.2 SpEL属性注入

下面咱使用 SpEL进行最简单的属性注入。SpEL 的语法统一用 **`#{}`** 表示，花括号内部编写表达式语言。

创建一个 `Blue` ，也是像上面一样声明 name 和 order ，并提供 getter 、setter 方法（为了方便后续操作）和 `toString()` 方法，最后用 `@Component` 标注。

使用 `@Value` 配合 SpEL 完成字面量的属性注入，需要额外在花括号内部加单引号：

```java
@Component
public class Blue {
    
    @Value("#{'blue-value-byspel'}")
    private String name;
    
    @Value("#{2}")
    private Integer order;
```

修改启动类，从 IOC 容器中取 `Blue` 并打印，可以发现字面量被成功注入：

```ini
Blue{name='blue-value-byspel', order=2}
```

#### 3.3.3 Bean属性引用

如果 SpEL 的功能仅仅是这样，那真的太弱鸡了，SpEL 可以取 IOC 容器中其它 Bean 的属性，下面咱来演示。

上面的注入中咱已经注册了 `Blue` ，下面咱再创建一个 `Green` ，以同样的方式对字段和方法进行声明，同时标注 `@Component` 注解。

在 name 属性上，咱希望直接拿 `Blue` 的 name 贴过来；order 属性希望它比 blue 的 order 大 1，则可以这样编写：

```java
@Component
public class Green {
    
    @Value("#{'copy of ' + blue.name}")
    private String name;
    
    @Value("#{blue.order + 1}")
    private Integer order;
```

修改启动类，测试运行，发现 `Blue` 的属性已经成功被取出了：

```ini
use spel bean property : Green{name='copy of blue-value-byspel', order=3}
```

xml 的使用方式也很简单：

```xml
<bean class="com.linkedbear.spring.basic_di.c_value_spel.bean.Green">
    <property name="name" value="#{'copy of ' + blue.name}"/>
    <property name="order" value="#{blue.order + 1}"/>
</bean>
```

#### 3.3.4 方法调用

SpEL 表达式不仅可以引用对象的属性，还可以直接引用类常量，以及调用对象的方法等，下面咱演示方法调用和常量引入。

新建一个 `White` ，以同样的方式初始化属性、`toString()` 、注解。

咱设想一个简单的需求，让 name 取 blue 属性的前 3 个字符，order 取 `Integer` 的最大值，则使用 SpEL 可以这样写：

```java
@Component
public class White {
    
    @Value("#{blue.name.substring(0, 3)}")
    private String name;
    
    @Value("#{T(java.lang.Integer).MAX_VALUE}")
    private Integer order;
```

注意，直接引用类的属性，需要在类的全限定名外面使用 **T()** 包围。

修改启动类，测试运行，发现 `White` 的属性已经是处理之后的值了：

```ini
use spel methods : White{name='blu', order=2147483647}
```

xml 的方式，同样都是使用 value 属性：

```xml
<bean class="com.linkedbear.spring.basic_di.c_value_spel.bean.White">
    <property name="name" value="#{blue.name.substring(0, 3)}"/>
    <property name="order" value="#{T(java.lang.Integer).MAX_VALUE}"/>
</bean>
```

小伙伴不要把过多的精力放到 SpEL 表达式上，简单学会一些基础的使用即可，更多的 SpEL 表达式使用方式，可以参照官方文档，这上面写的非常全：[docs.spring.io/spring/docs…](https://link.juejin.cn?target=https%3A%2F%2Fdocs.spring.io%2Fspring%2Fdocs%2F5.2.x%2Fspring-framework-reference%2Fcore.html%23expressions) 。

## 小结与练习

1. 动手练习上面讲解的几个演示案例，熟练掌握这几种基础的属性注入方式。

【最简单的学完了，下面咱来学习如何注入复杂类型的数据，以及 Bean 的依赖如何使用注解处理】

# 9. IOC基础-依赖注入-自动注入&复杂类型注入

上一章咱对最简单基础的属性注入有了比较全面的了解和学习，这一章咱要考虑另外一个问题了：一个 Bean 要依赖另一个 Bean 怎么办？在  xml 中可以声明 ref 属性，用注解怎么办？如果 Bean 里要注入复杂类型（数组、集合、Map 等）又需要怎么办呢？

## 1. 自动注入【掌握】

xml 中的 `ref` 属性可以在一个 Bean 中注入另一个 Bean ，注解同样也可以这样做，它可以使用的注解有很多种，咱一一来学习。

> 本小节源码位置均在 `com.linkedbear.spring.basic_di`

### 1.1 @Autowired

在 Bean 中直接在 **属性 / setter 方法** 上标注 `@Autowired` 注解，IOC 容器会**按照属性对应的类型，从容器中找对应类型的 Bean 赋值到对应的属性**上，实现自动注入。

咱来编写一个案例，以下部分均放在 `d_complexfield` 包下。

#### 1.1.1 创建Bean

预先创建好几个 Bean ，用来过会做演示用。

`Person` ：

```java
@Component
public class Person {
    private String name = "administrator";
    // setter
```

`Dog` ：

```java
@Component
public class Dog {
    
    @Value("dogdog")
    private String name;
    
    private Person person;
    // toString() ......
```

#### 1.1.2 给Dog注入Person的三种方式

对于 `@Autowired` 的使用，只需要在属性上标注即可：

```java
@Component
public class Dog {
    // ......
    @Autowired
    private Person person;
```

也可以使用构造器注入方式：

```java
@Component
public class Dog {
    // ......
    private Person person;
    
    @Autowired
    public Dog(Person person) {
        this.person = person;
    }
```

亦可以使用 setter 方法注入：

```java
@Component
public class Dog {
    // ......
    private Person person;
    
    @Autowired
    public void setPerson(Person person) {
        this.person = person;
    }
```

> 至于这三种方式的区别，下面会有专门的面试题整理，咱先往下学。

#### 1.1.3 测试启动类

编写启动类，把上面的 `Person` 和 `Dog` 都扫描进 IOC 容器，之后取出 `Dog` 并打印：

```java
public class InjectComplexFieldAnnoApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext("com.linkedbear.spring.basic_di.d_complexfield.bean");
        Dog dog = ctx.getBean(Dog.class);
        System.out.println(dog);
    }
}
```

运行，打印 `Dog` ，发现 `Dog` 里已经依赖了 `Person` ：

```ini
Dog{name='dogdog', person=Person{name='administrator'}}
```

#### 1.1.4 注入的Bean不存在

将 `Person` 上面的 `@Component` 暂时的注释掉，此时 IOC 容器中应该没有 `Person` 了吧，再次运行启动类，可以发现

```vbnet
Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.linkedbear.spring.basic_di.d_autowired.bean.Person' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
```

简单概括这个异常，就是说**本来想找一个类型为 `Person` 的 Bean ，但一个也没找到**！那必然没找到啊，`@Component` 注解被注释掉了，自然就不会注册了。如果出现这种情况下又不想让程序抛异常，就需要在 `@Autowired` 注解上加一个属性：**`required = false`** 。

```java
    @Autowired(required = false)
    private Person person;
```

再次运行启动类，可以发现控制台打印 `person=null` ，但没有抛出异常：

```ini
Dog{name='dogdog', person=null}
```

### 1.2 @Autowired在配置类的使用

`@Autowired` 不仅可以用在普通 Bean 的属性上，在配置类中，注册 `@Bean` 时也可以标注：

```java
@Configuration
@ComponentScan("com.linkedbear.spring.basic_di.d_complexfield.bean")
public class InjectComplexFieldConfiguration {

    @Bean
    @Autowired // 高版本可不标注
    public Cat cat(Person person) {
        Cat cat = new Cat();
        cat.setName("mimi");
        cat.setPerson(person);
        return cat;
    }
}
```

由于配置类的上下文中没有 `Person` 的注册了（使用了 `@Component` 模式注解），自然也就没有 `person()` 方法给咱调，那就可以使用 `@Autowired` 注解来进行自动注入了。（其实不用标，SpringFramework 也知道自己得注入了）

将扫描包换为配置类驱动，可以发现 cat 也能打印出来了：

```java
public static void main(String[] args) throws Exception {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(InjectComplexFieldConfiguration.class);

    Cat cat = ctx.getBean(Cat.class);
    System.out.println(cat);
}
```

### 1.3 多个相同类型Bean的自动注入

刚才咱已经使用 `@Component` 模式注解，在 `Person` 类上标注过了，此时 IOC 容器就应该有一个 `Person` 类型的 Bean 了。下面咱在配置类中再注册一个 ：

```java
    @Bean
    public Person master() {
        Person master = new Person();
        master.setName("master");
        return master;
    }
```

这样 IOC 容器就应该有两个 `Person` 对象了吧！接下来咱改一个地方，给 `Person` 的 `@Component` 加一个名称：

```java
@Component("administrator")
```

此时，两个 person 一个叫 master ，一个叫 administrator 。

下面咱直接运行测试启动类，可以发现控制台会报这样一个错误：

```vbnet
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.linkedbear.spring.basic_di.d_complexfield.bean.Person' available: expected single matching bean but found 2: administrator,master
```

IOC 容器发现有两个类型相同的 `Person` ，它也不知道注入哪一个了，索性直接 “我选择死亡” ，就挂了。

出现这个问题不能就这样不管啊，得先办法啊。SpringFramework 针对这种情况专门提供了两个注解，可以使用两种方式解决该问题。

#### 1.3.1 @Qualifier：指定注入Bean的名称

`@Qualifier` 注解的使用目标是要注入的 Bean ，它配合 `@Autowired` 使用，可以显式的指定要注入哪一个 Bean ：

```java
    @Autowired
    @Qualifier("administrator")
    private Person person;
```

重新运行测试类，可以发现 `Dog` 中注入的 `Person` 是 administrator 。

#### 1.3.2 @Primary：默认Bean

`@Primary` 注解的使用目标是被注入的 Bean ，在一个应用中，一个类型的 Bean 注册只能有一个，它配合 `@Bean` 使用，可以指定默认注入的 Bean ：

```java
    @Bean
    @Primary
    public Person master() {
        Person master = new Person();
        master.setName("master");
        return master;
    }
```

重新运行测试类，发现 `Cat` 中注入的 `Person` 是 master ，`Dog` 中注入的还是 administrator ，可见 `@Qualifier` 不受 `@Primary` 的干扰。

同样的，在 xml 中可以指定 `<bean>` 标签中的 `primary` 属性为 true ，跟上面标注 `@Primary` 注解是一样的。

#### 1.3.3 另外的办法

其实，如果不用上面的注解，也是可以解决问题的，只需要改一下变量名即可：

```java
    @Autowired
    private Person administrator;
```

重新运行测试类，发现可以注入了，而且没有报 `expected single matching bean but found 2` 的异常。

#### 1.3.4 【面试题】@Autowired注入的原理逻辑

由此可以总结出 `@Autowired` 的注入逻辑：（以下答案仅供参考，可根据自己的理解调整回答内容）

**先拿属性对应的类型，去 IOC 容器中找 Bean ，如果找到了一个，直接返回；如果找到多个类型一样的 Bean ，  把属性名拿过去，跟这些 Bean 的 id 逐个对比，如果有一个相同的，直接返回；如果没有任何相同的 id 与要注入的属性名相同，则会抛出 `NoUniqueBeanDefinitionException` 异常。**

### 1.4 多个相同类型Bean的全部注入

上面都是注入一个 Bean 的方式，通过两种不同的办法来保证注入的唯一性。但如果需要一下子把所有指定类型的 Bean 都注入进去应该怎么办呢？其实答案也挺简单的，**注入一个用单个对象接收，注入一组对象就用集合来接收**：

```java
@Component
public class Dog {
    // ......
    
    @Autowired
    private List<Person> persons;
```

如上就可以实现一次性把所有的 `Person` 都注入进来，重新运行启动类，可以发现 persons 中有两个对象：

```ini
Dog{name='dogdog', person=Person{name='administrator'}, persons=[Person{name='administrator'}, Person{name='master'}]}
```

以上就是关于 `@Autowired` 的使用，下面咱再介绍两个用于自动注入的规范。

### 1.5 JSR250-@Resource

介绍 JSR250 规范之前，先简单了解下 JSR 。

> JSR 全程 **Java Specification Requests** ，它定义了很多 Java 语言开发的规范，有专门的一个组织叫 JCP ( Java Community Process ) 来参与定制。
>
> 有关 JSR250 规范的说明文档可参考官方文档：[jcp.org/en/jsr/deta…](https://link.juejin.cn?target=https%3A%2F%2Fjcp.org%2Fen%2Fjsr%2Fdetail%3Fid%3D250)

回到正题，`@Resource` 也是用来属性注入的注解，它与 `@Autowired` 的不同之处在于：**`@Autowired` 是按照类型注入，`@Resource` 是直接按照属性名 / Bean的名称注入**。

是不是突然有点狂喜，这个 **`@Resource` 注解相当于标注 `@Autowired` 和 `@Qualifier`** 了！实际开发中，`@Resource` 注解也是用的很多的，可以根据情况来进行选择。

为了不与上面的代码起冲突，咱另创建一个 `Bird` ，也注入 `Person` ，不过这次咱直接用 `@Resource` 注解指定要注入的 Person ：

```java
@Component
public class Bird {
    
    @Resource(name = "master")
    private Person person;
```

之后在启动类中取出 `Bird` 并打印，可以发现确实正常注入了 name 为 "master" 的 `Person` 。

```ini
Bird{person=Person{name='master'}}
```

### 1.6 JSR330-@Inject

JSR330 也提出了跟 `@Autowired` 一样的策略，它也是**按照类型注入**。不过想要用 JSR330 的规范，需要额外导入一个依赖：

```xml
<!-- jsr330 -->
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
```

剩下的使用方式就跟 SpringFramework 原生的 `@Autowired` + `@Qualifier` 一样了：

```java
@Component
public class Cat {
    
    @Inject // 等同于@Autowired
    @Named("admin") // 等同于@Qualifier
    private Person master;
```

#### 1.6.1 @Autowired与@Inject对比

可能会有小伙伴问了，那这个 `@Inject` 都跟 SpringFramework 原生的 `@Autowired` 一个作用，那我还用它干嘛？来看一眼包名：

```kotlin
import org.springframework.beans.factory.annotation.Autowired;

import javax.inject.Inject;
```

是不是突然明白了点什么？如果万一项目中没有 SpringFramework 了，那么 `@Autowired` 注解将失效，但 `@Inject` 属于 **JSR 规范，不会因为一个框架失效而失去它的意义**，只要导入其它支持 JSR330 的 IOC 框架，它依然能起作用。

> 当然，话又说回来，当下的 JavaEE 开发，谁又能离得了 Spring 呢？（ヽ(￣▽￣)ﾉ）

------

最后，整理一下上面以及上一章出现的几个大的问题，总结成两道面试题。（面试题答案仅供参考，可根据自己的理解调整回答内容）

### 1.7 【面试题】依赖注入的注入方式

| 注入方式   | 被注入成员是否可变 | 是否依赖IOC框架的API                                         | 使用场景                           |
| ---------- | ------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 构造器注入 | 不可变             | 否（xml、编程式注入不依赖）                                  | 不可变的固定注入                   |
| 参数注入   | 不可变             | 否（高版本中注解配置类中的 `@Bean` 方法参数注入可不标注注解） | 注解配置类中 `@Bean` 方法注册 bean |
| 属性注入   | 不可变             | 是（只能通过标注注解来侵入式注入）                           | 通常用于不可变的固定注入           |
| setter注入 | 可变               | 否（xml、编程式注入不依赖）                                  | 可选属性的注入                     |

### 1.8 【面试题】自动注入的注解对比

| 注解       | 注入方式     | 是否支持@Primary | 来源                       | Bean不存在时处理                   |
| ---------- | ------------ | ---------------- | -------------------------- | ---------------------------------- |
| @Autowired | 根据类型注入 | 是               | SpringFramework原生注解    | 可指定required=false来避免注入失败 |
| @Resource  | 根据名称注入 | 是               | JSR250规范                 | 容器中不存在指定Bean会抛出异常     |
| @Inject    | 根据类型注入 | 是               | JSR330规范 ( 需要导jar包 ) | 容器中不存在指定Bean会抛出异常     |

`@Qualifier` ：如果被标注的成员/方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean

`@Primary` ：如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 “根据类型注入” 的注解时会注入标注 `@Primary` 注解的 bean

------

说完了 Bean 的注入，下面咱来看看复杂类型如何注入。

## 2. 复杂类型注入

这部分咱介绍的复杂类型注入包括如下几种：

- 数组
- List / Set
- Map
- Properties

其实看起来也不算复杂嘛。。。基本都是集合类型。。。那咱一个一个介绍。

> 本小节源码位置：`com.linkedbear.spring.basic_di.g_complexfield`

### 2.1 创建复杂对象

咱这次构造一个复杂的 Person ，里面的属性涵盖了上面涉及到的所有类型：

```java
public class Person {

    private String[] names;
    private List<String> tels;
    private Set<Cat> cats;
    private Map<String, Object> events;
    private Properties props;
    // setter
```

下面咱先来使用 xml 的方式注入属性。

### 2.2 xml复杂注入【掌握】

xml 注入复杂类型相对比较简单，咱先在 xml 中注册一个 `Person` （不要扫描 `Person` 所在的包）：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.linkedbear.spring.basic_di.g_complexfield.bean.Person"></bean>
</beans>
```

接下来，咱把其中的属性都一一赋值。

#### 2.2.1 数组注入

`<bean>` 标签中，要想给属性赋值，统统都是用 `<property>` 标签，对于简单注入和 Bean 的注入，可以通过 **value** 和 **ref** 完成，但复杂类型就必须在标签体内写子标签了。

`<property>` 标签中有好多子标签：

![img](./assets/d3dc9a25cb1c43e9bb78e5610dd1228e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

必然的，注入数组是用 `<array>` 标签咯，于是数组的注入可以这么写：

```xml
<property name="names">
    <array>
        <value>张三</value>
        <value>三三来迟</value>
    </array>
</property>
```

#### 2.2.2 List注入

array 与 list 的形式基本是一模一样的（本身 List 的底层就可以是数组），于是 List 的注入也很简单：

```xml
<property name="tels">
    <list>
        <value>13888</value>
        <value>15999</value>
    </list>
</property>
```

#### 2.2.3 Set注入

有木有小伙伴注意到，在写了 `<array>` 或者 `<list>` 标签后，里面的标签还是上面那一堆，说明集合是可以继续嵌套集合的吧！

在上面的 `Person` 模型中，Set 集合的泛型是 `Cat` ，也就说明咱要在这个集合中注入一组 Bean 。对于这些 Bean ，可以直接声明创建，也可以直接引用现有的 Bean 进行注入，如下所示：

```xml
<!-- 已经提前声明好的Cat -->
<bean id="mimi" class="com.linkedbear.spring.basic_di.g_complexfield.bean.Cat"/>
---

<property name="cats">
    <set>
        <bean class="com.linkedbear.spring.basic_di.g_complexfield.bean.Cat"/>
        <ref bean="mimi"/>
    </set>
</property>
```

#### 2.2.4 Map注入

**Map** 的底层是键值对，迭代的时候都是用 **Entry** 来取 key 和 value ，那在这里面也是这样设计的：（ key 和 value 都可以是 Bean 的引用）

```xml
<property name="events">
    <map>
        <entry key="8:00" value="起床"/>
        <!-- 撸猫 -->
        <entry key="9:00" value-ref="mimi"/>
        <!-- 买猫 -->
        <entry key="14:00">
            <bean class="com.linkedbear.spring.basic_di.g_complexfield.bean.Cat"/>
        </entry>
        <entry key="18:00" value="睡觉"/>
    </map>
</property>
```

#### 2.2.5 Properties注入

Properties 类型与 Map 其实是一模一样的，注入的方式也基本一样，只不过有一点：Properties 的 key 和 value 只能是 String 类型。

```xml
<property name="props">
    <props>
        <prop key="sex">男</prop>
        <prop key="age">18</prop>
    </props>
</property>
```

#### 2.2.6 测试启动类

编写启动类，加载 xml 文件，并取出 `Person` 打印，可以发现属性都被注入成功了：

```ini
Person{
  names=[张三, 三三来迟],
  tels=[13888, 15999],
  cats=[Cat{name='cat'}, Cat{name='cat'}],
  events={8:00=起床, 9:00=Cat{name='cat'}, 14:00=Cat{name='cat'}, 18:00=睡觉},
  props={age=18, sex=男}
}
```

### 2.3 注解复杂注入【会用】

为了能演示 Bean 的引用，咱给 `Cat` 加上 `@Component` 注解，并带上名称：

```java
@Component("miaomiao")
public class Cat {
    private String name = "cat";
```

下面咱进行注解注入。其实对于注解的注入，说白了还是借助 SpEL 表达式，上一章咱也说了，它的功能很强大，这一节咱继续体会一下。

这部分咱直接全部列出吧，使用 SpEL 表达式实现注解注入的方式：（江郎才尽了已经开始不知道注入什么东西好了 ~ ~ ~ 以下内容开始胡言乱语。。。）

```java
@Component
public class Person2 {
    
    @Value("#{new String[] {'张三', '张仨'}}")
    private String[] names;
    
    @Value("#{{'333333', '3333', '33'}}")
    private List<String> tels;
    
    // 引用现有的Bean，以及创建新的Bean
    @Value("#{{@miaomiao, new com.linkedbear.spring.basic_di.g_complexfield.bean.Cat()}}")
    private Set<Cat> cats;
    
    @Value("#{{'喵喵': @miaomiao.name, '猫猫': new com.linkedbear.spring.basic_di.g_complexfield.bean.Cat().name}}")
    private Map<String, Object> events;
    
    @Value("#{{'123': '牵着手', '456': '抬起头', '789': '我们私奔到月球'}}")
    private Properties props;
```

相应的，也都可以正常打印：

```ini
Person{
  names=[张三, 张仨],
  tels=[333333, 3333, 33],
  cats=[Cat{name='cat'}, Cat{name='cat'}],
  events={喵喵=miaomiao, 猫猫=cat},
  props={123=牵着手, 456=抬起头, 789=我们私奔到月球}
}
```

> 学是这么学，不过估计没什么人真的会在实际开发中这么肆无忌惮的用 SpEL 注入这种属性吧。。。
>
> 当然，别忘了，还有一种方式能做到复杂类型的注入：编程式。。。直接在配置类中声明 `@Bean` 注册也是可以的，这种方式最灵活。

到这里，复杂类型的注入也就介绍的差不多了。

## 小结与练习

1. 依赖注入的方式有哪几种？分别有什么特点？有什么区别？
2. `@Autowired` 、`@Resource` 、`@Inject` 之间的对比区别是什么？
3. 动手实现组件间的注入，以及复杂类型的注入。

【到这里，依赖注入的大部分内容也就都学完了，最后一部分咱学习两个不是太常用但含量蛮高的方式，作为依赖注入的收尾了】

# 10. IOC进阶-依赖注入-回调注入&延迟注入

对，这一章的难度算是进阶的，倒不是说难不难，只是这部分涉及的内容可能平时开发中用的相对少，做一个了解+会用即可。

## 1. 回调注入【熟悉】

说起这个回调，其实对于大多数情况来讲，已经不需要实现接口了，直接 `@Autowired` 就可以搞定。但这话不是绝对的，这些回调机制还是有用的，咱还是来学一学。

> 本小节源码位置：`com.linkedbear.spring.basic_di.h_aware`

### 1.1 回调的根源：Aware

回调注入的核心是一个叫 **`Aware`** 的接口，它来自 SpringFramework 3.1 ：

```java
public interface Aware {

}
```

它是一个空接口，底下有一系列子接口，借助 IDEA 的继承关系，可以发现还蛮多的：

![img](./assets/985ddf54f86a42c8a9484310afdaa719~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这里面，可能比较常用到的有这么几个，咱单独列出来讲解一下。

### 1.2 比较常用的几个回调接口

| 接口名                         | 用途                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| BeanFactoryAware               | 回调注入 BeanFactory                                         |
| ApplicationContextAware        | 回调注入 ApplicationContext（与上面不同，后续 IOC 高级讲解） |
| EnvironmentAware               | 回调注入 Environment（后续IOC高级讲解）                      |
| ApplicationEventPublisherAware | 回调注入事件发布器                                           |
| ResourceLoaderAware            | 回调注入资源加载器（xml驱动可用）                            |
| BeanClassLoaderAware           | 回调注入加载当前 Bean 的 ClassLoader                         |
| BeanNameAware                  | 回调注入当前 Bean 的名称                                     |

这里面大部分接口，其实在当下的 SpringFramework 5 版本中，借助 `@Autowired` 注解就可以实现注入了，根本不需要这些接口，只有最后面两个，是因 Bean 而异的，还是需要 **Aware** 接口来帮忙注入。下面咱来演示两个接口的作用，剩余的接口小伙伴们可以自行尝试编写体会一下即可。

### 1.3 ApplicationContextAware的使用

#### 1.3.1 创建Bean

新创建一个 `AwaredTestBean` ，用来实现这些 `Aware` 接口。咱先让它实现 `ApplicationContextAware` 接口：

```java
public class AwaredTestBean implements ApplicationContextAware {
    
    private ApplicationContext ctx;
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        this.ctx = ctx;
    }
}
```

这样就相当于，当这个 `AwaredTestBean` 被初始化好的时候，就会把 `ApplicationContext` 传给它，之后它就可以干自己想干的事了。那咱为了测试效果，咱就打印一下 IOC 容器内部的所有 bean 的名称吧：

```java
public class AwaredTestBean implements ApplicationContextAware {
    
    private ApplicationContext ctx;
    
    public void printBeanNames() {
        Stream.of(ctx.getBeanDefinitionNames()).forEach(System.out::println);
    }
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        this.ctx = ctx;
    }
}
```

#### 1.3.2 创建配置类

之后，编写一个配置类，创建这个 `AwaredTestBean` （没有选择直接用包扫描，是为了演示下面的 `BeanNameAware` 接口）：

```java
@Configuration
public class AwareConfiguration {
    
    @Bean
    public AwaredTestBean bbb() {
        return new AwaredTestBean();
    }
}
```

#### 1.3.3 编写启动类

最后，编写测试启动类，并从容器中取出 `AwaredTestBean` ，调用它的 `printBeanNames` 方法：

```java
public class AwareApplication {
    
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(AwareConfiguration.class);
        AwaredTestBean bbb = ctx.getBean(AwaredTestBean.class);
        bbb.printBeanNames();
    }
}
```

运行 `main` 方法，发现容器中的 bean 名称一一被打印，说明 `ApplicationContext` 已经成功注入到 `AwaredTestBean` 中了。

### 1.4 BeanNameAware的使用

如果当前的 bean 需要依赖它本身的 name ，使用 `@Autowired` 就不好使了，这个时候就得使用 `BeanNameAware` 接口来辅助注入当前 bean 的 name 了。

#### 1.4.1 修改bean

给 `AwaredTestBean` 再实现 `BeanNameAware` 接口，并增加 `getName` 方法：

```java
public class AwaredTestBean implements ApplicationContextAware, BeanNameAware {
    
    private String beanName;
    private ApplicationContext ctx;
    
    public String getName() {
        return beanName;
    }
    
    public void printBeanNames() {
        Stream.of(ctx.getBeanDefinitionNames()).forEach(System.out::println);
    }
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        this.ctx = ctx;
    }
    
    @Override
    public void setBeanName(String name) {
        this.beanName = name;
    }
}
```

修改启动类，添加 `getName` 方法的调用并打印：

```java
    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(AwareConfiguration.class);
        AwaredTestBean bbb = ctx.getBean(AwaredTestBean.class);
        bbb.printBeanNames();
        System.out.println("-----------");
        System.out.println(bbb.getName());
    }
```

运行 `main` 方法，发现 bbb 已经成功打印出来了，证明 bean 的 name 已经成功注入到 bean 中了。

#### 1.4.2 NamedBean

其实，`BeanNameAware` 还有一个可选的搭配接口：**`NamedBean`** ，它专门提供了一个 `getBeanName` 方法，用于获取 bean 的 name 。

所以说，如果给上面的 `AwaredTestBean` 再实现 `NamedBean` 接口，那就不需要自己定义 `getName` 或者 `getBeanName` 方法，直接实现 `NamedBean` 定义好的 `getBeanName` 方法即可。它的使用方式非常简单，小册就不再演示了。

以上就是对回调注入的简单介绍了，其它的接口小伙伴们可以自行测试。

> 多提一嘴，`@Autowired` 注入 SpringFramework 内置组件并不是在所有场景都适用的，后续 IOC 高级中会解释这个问题。

## 2. 延迟注入【熟悉】

提到延迟注入，是不是就想起来之前学习依赖查找时的延迟查找了呢？还真就这么回事，下面咱再看看 `ObjectProvider` 如何应用于延迟注入。

> 本小节源码位置：`com.linkedbear.spring.basic_di.i_lazyinject`

### 2.1 setter的延迟注入

之前咱在写 setter 注入时，直接在 setter 中标注 `@Autowired` ，并注入对应的 bean 即可。如果使用延迟注入，则注入的就应该换成 `ObjectProvider` ：

```java
@Component
public class Dog {
    
    private Person person;
    
    @Autowired
    public void setPerson(ObjectProvider<Person> person) {
        // 有Bean才取出，注入
        this.person = person.getIfAvailable();
    }
```

如此设计，可以防止 Bean 不存在时出现异常。

### 2.2 构造器的延迟注入

构造器的延迟注入与 setter 方式不要太像：

```java
@Component
public class Dog {
    
    private Person person;
    
    @Autowired
    public Dog(ObjectProvider<Person> person) {
        // 如果没有Bean，则采用缺省策略创建
        this.person = person.getIfAvailable(Person::new);
    }
```

效果跟 setter 是一样的，只不过 setter 的注入时机是创建对象**后**，而构造器的注入时机是创建对象**时**。

### 2.3 属性字段的延迟注入

属性直接注入是不能直接注入 Bean 的，只能注入 `ObjectProvider` ，通常也不会这么干，因为这样注入了之后，每次要用这个 Bean 的时候都得判断一次：

```java
    @Autowired
    private ObjectProvider<Person> person;
    
    @Override
    public String toString() {
        // 每用一次都要getIfAvailable一次
        return "Dog{" + "person=" + person.getIfAvailable(Person::new) + '}';
    }
```

到这里，延迟注入的内容也就介绍的差不多了，关于 `ObjectProvider` 的使用咱在第 6 章也介绍过一些，这里咱就不多重复了。

### 2.4 【面试题】依赖注入的注入方式-扩展

以下答案仅供参考，可根据自己的理解调整回答内容：

| 注入方式   | 被注入成员是否可变 | 是否依赖IOC框架的API               | 注入时机   | 使用场景                 | 支持延迟注入 |
| ---------- | ------------------ | ---------------------------------- | ---------- | ------------------------ | ------------ |
| 构造器注入 | 不可变             | 否（xml、编程式注入不依赖）        | 对象创建时 | 不可变的固定注入         | 是           |
| 参数注入   | 不可变             | 是（只能通过标注注解来侵入式注入） | 对象创建后 | 通常用于不可变的固定注入 | 否           |
| setter注入 | 可变               | 否（xml、编程式注入不依赖）        | 对象创建后 | 可选属性的注入           | 是           |

------

最后，咱对依赖注入作一个面试题级别的总结，帮助小伙伴好好理解依赖注入的思想。

## 3. 【面试题】依赖注入4连问

### 3.1 依赖注入的目的和优点？

首先，依赖注入作为 IOC 的实现方式之一，目的就是**解耦**，我们不再需要直接去 new 那些依赖的类对象（直接依赖会导致对象的创建机制、初始化过程难以统一控制）；而且，如果组件存在多级依赖，依赖注入可以将这些依赖的关系简化，开发者只需要定义好谁依赖谁即可。

除此之外，依赖注入的另一个特点是依赖对象的**可配置**：通过 xml 或者注解声明，可以指定和调整组件注入的对象，借助 Java 的多态特性，可以不需要大批量的修改就完成依赖注入的对象替换（面向接口编程与依赖注入配合近乎完美）。

### 3.2 谁把什么注入给谁了？

由于组件与组件之间的依赖只剩下成员属性 + 依赖注入的注解，而注入的注解又被 SpringFramework 支持，所以这个问题也好回答：**IOC 容器把需要依赖的对象注入给待注入的组件**。

### 3.3 依赖注入具体是如何注入的？

关于 `@Autowired` 注解的注入逻辑，在第 9 章 1.3.4 节有提过；`@Resource` 和 `@Inject` 的注入方式也都在第 9 章的 1.8 节罗列出来了，小伙伴们可以根据表格内容整理，灵活回答即可。

至于里面的注入逻辑，小册不打算在这里详细展开，会放到后续 IOC 原理篇，解析 Bean 的生命周期时详细解释依赖注入的原理。

### 3.4 使用setter注入还是构造器注入？

这个问题，最好的保险回答是引用官方文档，而官方文档在不同的版本推荐的注入方式也不同，具体可参照如下回答：

- SpringFramework **4.0.2** 及之前是推荐 setter 注入，理由是**一个 Bean 有多个依赖时，构造器的参数列表会很长**；而且如果 **Bean 中依赖的属性不都是必需的话，注入会变得更麻烦**；
- **4.0.3** 及以后官方推荐构造器注入，理由是**构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null** ；
- 当然 **4.0.3** 及以后的官方文档中也说了，如果**真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解**。

![img](./assets/189e28f36ac94ad0b3948502df59e365~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## 小结与练习

1. 什么是回调注入？回调注入都可以注入什么？
2. 依赖注入如何实现延迟注入？

【到这里，有关依赖注入的部分就算是讲解完毕了。下面的几章，咱会把目标聚焦在 Bean 上，研究 SpringFramework 中对 Bean 的设计和支持】