---
title: java基础知识补充
date: 2022-08-28 18:12:39
permalink: /pages/3ca163/
titleTag: 原创
categories:
  - 后端
  - Java
tags:
  - 
author: 
  name: Yunzhi Li
  link: https://github.com/liyi243/blog
---
### 基础知识补充

#### 短路逻辑运算符

- 逻辑与&，无论左边真假，右边都要执行。 
- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。 
- 逻辑或|，无论左边真假，右边都要执行。 
- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。

#### 跳转控制语句

（break）跳出循环，结束循环

（continue）跳过某次循环体内容的执行

#### String和StringBuilder

#### final与static

fianl关键字的作用
。final代表最终的意思，可以修饰成员方法，成员变量，类
final修饰类、方法、变量的效果
。fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）
。final修饰方法：该方法不能被重写
。final修饰变量：表明该变量是一个常量，不能再次赋值

#### Lambda



## 设计模式

## java三种工厂设计模式

### 1. 简单工厂模式

简单工厂有以下三个主角：

- **Factory**:工厂负责生产产品
- **AbstructProduct**:抽象产品，就好比华为手机，我没说是华为那个型号手机。
- **Product**:具体产品，就比如华为mate50。

我想要华为mate50手机，那华为mate50手机首先是华为手机，华为手机有什么功能就在下面接口写了。

```java
public interface HuaweiiPhone {
    void call();
}
```

华为手机有mate50、p40、荣耀等等很多个手机，那我就要写个类来具体实现比如mate50手机了。下面就**明确了华为手机有哪些**了。

```java
public class Mate50 implements HuaweiiPhone{
    @Override
    public void call() {
        System.out.println("use mate50 call phone...");
    }
}
public class P40 implements HuaweiiPhone{
    @Override
    public void call() {
        System.out.println("use p40 call phone...");
    }
}
```

知道华为手机有mate50、p40等这些手机，现在就要让工厂去把手机做出来了。下面这个工厂做了mate50和p40。

```java
public class PhoneFactory {
    //创建什么手机，就是什么返回值类型
    public static HuaweiiPhone getiPhone(String phoneType){
        if("mate50".equalsIgnoreCase(phoneType)){
            return new Mate50();
        } else if ("p40".equalsIgnoreCase(phoneType)) {
            return new P40();
        }else {
            throw  new RuntimeException("没有这个产品...");
        }
    }
}
```

用户想买那个手机，就去这个店里（工厂）购买就行了。

```java
public class Client {
    public static void main(String[] args) {
        HuaweiiPhone mate50 = PhoneFactory.getiPhone("mate50");
        mate50.call();
    }
}
```

以上就是简单工厂模式了。

### 2. 工厂方法模式

了解了简单工厂模式，我们来思考一下简单工厂模式有什么缺陷？
举个例子，有一天我要新增一个产品华为荣耀，我就必须去修改工厂（PhoneFactory）代码了，这就有点不灵活了。这种情况的解决方案就是工厂方法模式，下面详细说一下工厂方法模式。

工厂方法模式有四个主角：

- **AbstructFactory**:抽象工厂，抽象工厂就用来生产具体工厂，比如华为公司。
- **Factory**:具体工厂，具体工厂就是说每个型号的手机都会有一个专门的生产工厂，比如华为公司下的mate50生产线。
- **AbstructProduct**:抽象产品
- **Product**:具体产品

先写一个抽象工厂用于生产手机工厂，抽象工厂就好比建立一个手机公司,专门用来生产手机。

```java
public interface AbstractFactory {
    HuaweiiPhone product();
}
```

这个手机公司下有很多生产线，比如生产mate50的，生产p40的，生产荣耀的。就是说某个型号的手机生产就是具体工厂。下面这两个分别是生产mate50和p40的工厂,这两个工厂实现抽象工厂。

```java
public class Mate50Factory implements AbstractFactory{
    @Override
    public HuaweiiPhone product() {
        return new Mate50() ;
    }
}
public class P40Factory implements AbstractFactory{
    @Override
    public HuaweiiPhone product() {
        return new P40();
    }
}
```

然后呢mate50是什么？p40又是什么？它们是个手机，所以我们要建一个抽象手机的接口。

```java
public interface HuaweiiPhone {
    void call();
}
```

具体的mate50、p40实现了这个手机接口，我们才知道是个手机嘛。

```java
public class Mate50 implements HuaweiiPhone {
    @Override
    public void call() {
        System.out.println("use mate50 call phone...");
    }
}
public class P40 implements HuaweiiPhone {
    @Override
    public void call() {
        System.out.println("use p40 call phone...");
    }
}
```

最后这里是用户测试。

```java
public class Client {
    public static void main(String[] args) {
        Mate50Factory mate50Factory = new Mate50Factory();
        HuaweiiPhone product = mate50Factory.product();
        product.call();
    }
}
```

这部分就是我们所说的工厂方法模式了。

### 3. 抽象工厂模式

最后这里提一下抽象工厂模式。抽象工厂模式其实就比工厂方法模式多了个业务，华为公司并不是只生产手机的吧，也有电脑啊耳机啊什么的。 抽象工厂模式解决就是新增的一个业务。
举个例子，现在华为公司卖华为电脑和华为手机，小米公司卖小米电脑和小米手机，对我们用户来说买手机就多了选择什么品牌的手机。这差不多就是抽象工厂模式的核心思想了。

## 创建者设计模式

分离对象子组件的单独构造（由Buider来负责）和装配（由Director负责）。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。

 由于实现构造和装配的解耦。不同的构造器，相同的装配，也可以做出不同的对象；相同的构造器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。

 最典型的就是我们的StringBuilder和StringBuffer。

建造者模式包含如下角色：

- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色
  下面通过代码进行介绍。

computer类，创建方法很简单，就是一个简单的实体类。这个类在这里就好比我们要做电脑，买了几个主件，键盘啊、cpu啊主板啊什么都。

```java
/**
 * @ClassName 复杂的computer类
 * @Description ：创建者设计模式
 **/
public class Computer {
    private String mouse;
    private String keyboard;
    private String cpu;
    private String memeoryBank;
    private String mainBoard;

    @Override
    public String toString() {
        return "Computer{" +
                "mouse='" + mouse + '\'' +
                ", keyboard='" + keyboard + '\'' +
                ", cpu='" + cpu + '\'' +
                ", memeoryBank='" + memeoryBank + '\'' +
                ", mainBoard='" + mainBoard + '\'' +
                '}';
    }

    public String getMouse() {
        return mouse;
    }

    public void setMouse(String mouse) {
        this.mouse = mouse;
    }

    public String getKeyboard() {
        return keyboard;
    }

    public void setKeyboard(String keyboard) {
        this.keyboard = keyboard;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getMemeoryBank() {
        return memeoryBank;
    }

    public void setMemeoryBank(String memeoryBank) {
        this.memeoryBank = memeoryBank;
    }

    public String getMainBoard() {
        return mainBoard;
    }

    public void setMainBoard(String mainBoard) {
        this.mainBoard = mainBoard;
    }

}
```

买了这些主件后，要组装一台电脑还有很多复杂的程序，我们可以卸载builder里面，完成这些工序。

```java
/**
 * @Description ：用于创建computer
 **/
public class Builder {
    private final Computer computer =new Computer();
    public Builder buildMouse(String type){
        computer.setMouse("安装了"+ type + "鼠标");
        return this;
    }
    public Builder buildKeyboard(String type){
        computer.setKeyboard("安装了"+ type + "键盘");
        return this;
    }
    public Builder buildCPU(String type){
        computer.setCpu("安装了"+ type + "CPU");
        return this;
    }
    public Builder buildMainBoard(String type){
        computer.setMainBoard("安装了"+ type + "主板");
        return this;
    }
    public Builder buildMemeoryBank(String type){
        computer.setMemeoryBank("安装了"+ type + "鼠标");
        return this;
    }
    public Computer bulid(){
        return computer;
    }
}
```

当这些固定的加工手续定义好之后，下面就该制作生产了。下面这个测试类就按工序一步一步把电脑给我们组装好了。

```java
/**
 * @ClassName 测试创建者模式创建东西
 * @Description
 * @Author:liyunzhi
 * @Date
 * @Version 1.0
 **/
public class BuilderTest {
    public static void main(String[] args) {
        Computer computer = new Builder()
                .buildMainBoard("华硕")
                .buildCPU("i9-11100")
                .buildMemeoryBank("金士顿")
                .buildKeyboard("联想")
                .buildMouse("华为")
                .bulid();
        System.out.println(computer);
    }
}
```

## 代理设计模式

首先要明确一点：你为什么要做代理？不就是想找专业的人帮你做事嘛。
在我看来，代理的核心功能就是方法增强。

### 1. 静态代理模式

方法增强有两种，一种是类继承，另一种是实现共同一个接口（这一点有点蒙，继续往下看）。

#### 继承类实现方法增强

首先定一个接口，就用歌手唱歌来举例。下面定义了一个歌手接口。

```java
public interface Singer {
    void sing();
}
```

现在有一个男歌手，男歌手会唱歌对不对，歌手嘛～
我们让这个男歌手掌握唱歌的技能，就是实现了歌手这个接口。

```java
public class ManSinger implements Singer{
    //歌手需要一个名字
    private String name;
    //构造器给他名字
    public ManSinger(String name) {
        this.name = name;
    }

    @Override
    public void sing() {
        System.out.println("开始唱歌了！");
    }
}
```

现在那有个活动策划人来找他，希望这个男歌手可以唱个歌开个演唱会。那歌手懵了啊，我就会唱歌，开演唱会这个工作我不会啊，那怎么办？
那他只能找个人帮他谈好场地，弄好开演唱会的除了唱的所有事情了，这个人就是他的经纪人呀。我们需要这个经济人去包装一下这个歌手，下面看代码实现。

```java
public class Agent extends ManSinger {

    private ManSinger manSinger;

    public void setManSinger(ManSinger manSinger) {
        this.manSinger = manSinger;
    }

    @Override
    public void sing() {
        System.out.println("节目组找过来！需要演出，谈好演出费用。。。。。");
        manSinger.sing();
        System.out.println("结算费用，下一次合作预约。。。。。。");
    }
}
```

那这样歌手就可以安安心心的去唱歌了。

```java
public class Client {
    public static void main(String[] args) {
        ManSinger manSinger = new ManSinger("鹿晗");
        Agent agent = new Agent();
        agent.setManSinger(manSinger);
        agent.sing();
    }
}
```

#### 实现接口实现方法增强

第二中方法就是我们不让这个代理去继承男歌手这个类了，直接让他去实现歌手这个接口，来达到方法增强的目的。

```java
public class Agent implements Singer{
    private Singer singer;

    public Agent(Singer singer) {
        this.singer = singer;
    }

    @Override
    public void sing() {
        System.out.println("节目组找过来！需要演出，谈好演出费用。。。。。");
        singer.sing();
        System.out.println("结算费用，下一次合作预约。。。。。。");
    }
}
```

歌手依然可以好好唱歌了。

```java
public class Client {
    public static void main(String[] args) {
        ManSinger singer = new ManSinger("鹿晗");
        Singer agent = new Agent(singer);
        agent.sing();
    }
}
```

#### 优点

- 男歌手还是男歌手，没有必要为了一下前置后置工作改变男歌手这个类
- 公共的统一问题交给代理处理
- 公共业务进行扩展或变更时，可以更加方便
- 这不就是更加符合开闭原则，单一原则吗?

#### 缺点

- 缺点就是每个类都要写个代理，太麻烦了。

以上就是静态代理的所有内容了。

### 动态代理

什么是动态代理？

- 动态代理的角色和静态代理的一样
- 动态代理的代理类是动态生成的 ，静态代理的代理类是我们写的
- 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理
  - 基于接口的动态代理----JDK动态代理
  - 基于类的动态代理--cglib

动态代理就是当有大量的类需要执行一些共同代码时，我们自己写太麻烦，那能不能直接使用java代码，自动生成一个类帮助我们批量的增强某些方法。

#### JDK原生的动态代理

【核心】:InvocationHandler和Proxy

具体从代码部分入手帮助大家理解。 我现在写了个singer接口，如下。

```java
public interface Singer {
    void sing();
}
```

现在有个男歌手，当然他要达到某个标准才能成为一个歌手，所以这个男歌手要实现singer这个接口，这个标准，最后成了一个真正的男歌手。 具体实现如下：

```java
public class ManSinger implements Singer {
    //歌手需要一个名字
    private String name;
    //构造器给他名字

    public ManSinger(String name) {
        this.name = name;
    }

    @Override
    public void sing() {
        System.out.println(name+"开始唱歌了！");
    }
}
```

正如之前静态代理那块说的，歌手只会唱歌，举办演唱会其他事宜，包括协商价格、演唱会怎么举办歌手并不懂，所以他需要一个经纪人。我们就定义一个动态代理类来表示这个经纪人，如下。

```java
public class Agent implements InvocationHandler {
    //要代理的对象
    private Singer singer;
    public Agent(Singer singer) {
        this.singer = singer;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("经纪人把把关...");
        //singer.sing();
        Object runObj = method.invoke(singer, args);
        System.out.println("唱完了...");
        return runObj;
    }
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{Singer.class},this);
    }
}
```

先声明一下需要代理的对象，我们需要代理的接口类型是Singer，这里可以理解成这个代理类负责去卖singer这个接口标准的插座。
invoke这个方法就是使用处理代理实例上的方法，这个方法有三个参数:

- 第一个参数proxy是要代理的实例;
- 第二个参数method是要处理的方法，对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口;
- args包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean。

其实就是只要写invoke这个方法就可以了，正如我要代理singer这个接口实例，我就把singer传了进去，把代理要做的事情写在invoke方法前后，去增强这个接口方法。 而getProxy这个函数就是返回一个代理实例，给我们生成一个代理对象。下面说一下测试部分。

```java
public class Client {
    public static void main(String[] args) {
        ManSinger luhan = new ManSinger("luhan");
        Agent agent = new Agent(luhan);
        //agent.setSinger(luhan);
        Singer singer = (Singer)agent.getProxy();
        singer.sing();
    }
}
```

测试代码解释：这里就好比有一个男歌手luhan，然后他去找了个agent经纪人，或者说有个经纪人来找luhan了。然后他用自己的invoke来帮我们筹划演唱会的各种事宜，最后用getProxy把这个演唱会打包。

- 